import os

def get_fasta_basename(filename):
    """Return basename of fasta/fastq file"""
    filename = os.path.basename(filename)
    possible_ext = [".fastq", ".fq.gz", ".fastq.gz", ".fasta", ".fa", ".fa.gz",
        ".fasta.gz", ".bam", ".sam"]
    for e in possible_ext:
        if filename.endswith(e):
            return filename[:-len(e)]
    return filename

configfile: "tumor_normal_config.yaml"

UNIT_TO_SAMPLE = {
    unit: sample for sample, units in config["samples"].items()
    for unit in units}

from snakemake.exceptions import MissingInputException

fastqs = [item for sublist in list(config["units"].values()) for item in sublist]
FastQCs = ["FastQC/"+get_fasta_basename(fq)+"_fastqc.html" for fq in fastqs]
tumorBam = "final_bams/Human_b37/" + config["samples"]["tumor"][0] + "_rescued.realigned.bam.bai"
normalBam = "final_bams/Human_b37/" + config["samples"]["normal"][0] + "_rescued.realigned.bam.bai"


rule all:
        input:
            FastQCs, tumorBam, normalBam

rule clean:
    shell:
        "rm -rf mapping && rm -rf logs && rm -rf FastQC && rm -rf FastqBMF"
        " && rm -rf rescued_reads && rm -rf final_bams"

rule cutadapt_index_read:
    input:
        lambda wildcards: config["idx"][wildcards.unit]
    output:
        "FastqBMF/{unit}.ca.R2.fastq.gz"
    log:
        "logs/_01_cutadapt_index/{unit}_index.log"
    params:
        three = config["params"]["cutadapt"]["3pAdapter"],
        five = config["params"]["cutadapt"]["5pAdapter"],
        args = config["params"]["cutadapt"]["args"]
    shell:
        "cutadapt {params.args} -a {params.three} -g {params.five} "
        " -o {output} {input} >> {log} 2>> {log}"


###Consilidates reads by barcode using BMFtools#####
rule consolidate_by_barcode:
    input:
        fqs = lambda wildcards: config["units"][wildcards.unit],
        idx = "FastqBMF/{unit}.ca.R2.fastq.gz"
    output:
        "FastqBMF/{unit}.R1.fq.gz",
        "FastqBMF/{unit}.R2.fq.gz"
    log:
        "logs/_01_Read_Collapse/{unit}_dmp.log"
    threads:
        config["params"]["threads"]["bwa"]
    params:
        dmp = config["params"]["bmftools"]["sdmp"],
    shell:
        "bmftools sdmp {params.dmp} -i {input.idx} -p {threads} "
        "-o FastqBMF/{wildcards.unit}_tmp -f FastqBMF/{wildcards.unit} "
        " {input.fqs} 2> {log}"


rule cutadapt:
    input:
        "FastqBMF/{unit}.R1.fq.gz",
        "FastqBMF/{unit}.R2.fq.gz"
    output:
        fq1 = "FastqBMF/{unit}.ca.R1.fq.gz",
        fq2 = "FastqBMF/{unit}.ca.R2.fq.gz"
    params:
        three = config["params"]["cutadapt"]["3pAdapter"],
        five = config["params"]["cutadapt"]["5pAdapter"],
        args = config["params"]["cutadapt"]["args"]
    log:
        "logs/_02_cutadapt/{unit}.log"
    shell:
        "cutadapt {params.args} -a {params.three} -g {params.five} -A {params.three} "
        "-G {params.five} -o {output.fq1} -p {output.fq2} {input} "
        ">> {log} 2>> {log}"


###Maps consolidated reads to reference, and marks the unclipped start###
###position for rescued                                               ###
rule bwa_mem_map_and_rescue:
    input:
        lambda wildcards: config["references"][wildcards.reference],
        "FastqBMF/{unit}.ca.R1.fq.gz",
        "FastqBMF/{unit}.ca.R2.fq.gz"
    output:
        bam = "mapping/{reference}/{unit}.rescueRemoved.bam",
        fastq = "mapping/{reference}/{unit}.rescued.fastq"
    params:
        sample = lambda wildcards: UNIT_TO_SAMPLE[wildcards.unit],
        bwa = config["params"]["bs_bwa"],
        thread_mem = config["params"]["thread_mem"]
    log:
        "logs/_02_Map_Mark_Sort/{unit}.log"
    threads: config["params"]["threads"]["bmftools"]
    shell:
        "bwa mem {params.bwa} -R '@RG\tID:{wildcards.unit}\tSM:{params.sample}\tPL:{config[platform]}' "
        "-t {threads} {input}  2>> {log} | bmftools mark -l 0 - -  "
        " 2>> {log}  | bmftools sort  -l 0 -m {params.thread_mem} -@ {threads} "
        "-k ucs -T {output.bam}_tmp 2>> {log} | bmftools rsq -uf "
        "{output.fastq} -l 0 - - 2>> {log} | samtools sort -O bam -T "
        "{output.bam}_tmp -@ {threads} -m {params.thread_mem}"
        " -o {output.bam} 2>> {log} "


###Re-aligns reads with errored barcodes and combines them with the rest ###
rule align_merge_rescue:
    input:
        bam = "mapping/{reference}/{unit}.rescueRemoved.bam",
        fastq = "mapping/{reference}/{unit}.rescued.fastq",
        ref = config["references"]["Human_b37"]
    output:
        "rescued_reads/{reference}/{unit}_rescued.bam"
    log:
        "logs/_04_rescue_merge/{unit}.log"
    params:
        sample=lambda wildcards: UNIT_TO_SAMPLE[wildcards.unit],
        thread_mem = config["params"]["thread_mem"]
    threads: config["params"]["threads"]["bwa"]
    shell:
        "cat {input.fastq} | paste -d\'~\' - - - - | sort | tr \'~\' \'\\n\' |"
        " bwa mem -pCYT0 -t {threads} -R '@RG\tID:{wildcards.unit}\t"
        "SM:{params.sample}\tPL:{config[platform]}' {input.ref} - 2>> {log} | "
        "bmftools mark -l 0 - - 2>> {log} | samtools sort -l 0 -O bam "
        "-T temprsqsort -O bam -@ {threads} -m {params.thread_mem} - 2>> {log} | "
        "samtools merge -cp -h {input.bam} {output} {input.bam} - 2>> {log}"


###Indexes rescued bams for indel relignment###
rule index_bams:
    input:
        "rescued_reads/{reference}/{unit}_rescued.bam"
    output:
        "rescued_reads/{reference}/{unit}_rescued.bam.bai"
    log:
        "logs/_06_index_bams/{unit}.log"
    shell:
        "samtools index {input} 2> {log}"


###GATK's indel relignment prep###
rule gatk_realign_info:
    input:
        "rescued_reads/{reference}/{prefix}_rescued.bam.bai",
        ref=config["references"]["Human_b37"],
        bam="rescued_reads/{reference}/{prefix}_rescued.bam"
    output:
        temp("rescued_reads/{reference}/{prefix}_rescued.realign.intervals")
    log:
        "logs/_07_indel_realign/{prefix}.realign_info.log"
    threads: config["params"]["threads"]["other"]
    params:
        gatk = config["params"]["gatk"]
    shell:
        "{params.gatk} -T RealignerTargetCreator -R {input.ref} "
        "-nt {threads} "
        "-I {input.bam} -known {config[references][dbSNP]} "
        "-o {output} >& {log}"


###realigns using targets created by previous rule###
rule gatk_realign_bam:
    input:
        ref=config["references"]["Human_b37"],
        bam="rescued_reads/{reference}/{prefix}_rescued.bam",
        intervals="rescued_reads/{reference}/{prefix}_rescued.realign.intervals"
    output:
        "final_bams/{reference}/{prefix}_rescued.realigned.bam"
    params:
        gatk = config["params"]["gatk"]
    log:
        "logs/_07_indel_realign/{prefix}.realign.log"
    shell:
        "{params.gatk} -T IndelRealigner -R {input.ref} "
        "--disable_bam_indexing "
        "-I {input.bam} -targetIntervals {input.intervals} "
        "-o {output} >& {log}"


###Re-indexes final bams, now ready for variant calling###
rule re_index_bams:
    input:
        "final_bams/{reference}/{unit}_rescued.realigned.bam"
    output:
        "final_bams/{reference}/{unit}_rescued.realigned.bam.bai"
    log:
        "logs/_07_reindex_bams/{unit}.log"
    shell:
        "samtools index {input} 2> {log}"


###Runs FastQC on all FASTQs in the FASTQ directory###
rule fastqc:
    input:
        "FASTQ/{sample}.fastq.gz"
    output:
        "FastQC/{sample}_fastqc.html",
        "FastQC/{sample}_fastqc.zip"
    log:
        "logs/__QC/{sample}_fastqc.log"
    run:
        if not os.path.exists("FastQC"):
            os.makedirs("FastQC")
        shell("~/bin/FastQC/fastqc {input} --outdir FastQC >> {log} 2> {log}")


###run bmftools famstats on final bams###
rule famstats:
    input:
        "final_bams/{reference}/{unit}_rescued.bam"
    output:
        "famstats/{unit}_rescued_famstats.txt"
    log:
        "logs/_08_Run_Statistics/{unit}_famstats.log"
    shell:
        "bmftools famstats fm {input} > {output} 2> {log}"
