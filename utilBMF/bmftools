#!/usr/bin/env python
import sys
#  import warnings # Uncomment this if you want to treat warnings as errors.
from utilBMF.HTSUtils import printlog as pl, TrimExt
from MawCluster.BCBam import pairedBarcodeTagging, singleBarcodeTagging
from utilBMF.ArgumentSketcher import ArgumentSketcher
#  from pudb import set_trace

"""
bmftools contains various utilities for barcoded reads and for
somatic variant calling. Written to be similar in form to bcftools
and samtools.
"""

#  warnings.filterwarnings('error')


def main():
    import argparse
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="bmfsuites")
    alignTagBamParser = subparsers.add_parser(
        "aligntagbam", description=("Performs alignment and sam tagging of"
                                    " consolidated fastq files to generate "
                                    "a tagged bam."))
    TagBamParser = subparsers.add_parser(
        "tagbam", description=("Tag a BAM file with appropriate information"
                               " from merged fastq files."))
    RescueShadingParser = subparsers.add_parser(
        "rsq", description="Rescue fastq shading.")
    versionParser = subparsers.add_parser(
        "v", description="Outputs version of BMFTools.")
    InputQtyParser = subparsers.add_parser(
        "qty",
        description=("Calculates the quantity of input DNA needed to reach "
                     "a given mean PCR redundancy and a given amount of "
                     "sequencing power."))
    PSNVParser = subparsers.add_parser(
        "psnv", description="Parallel SNV calls.")
    PSNVParser.add_argument(
        "--conf",
        help="Config file to hold this so we don't have to specify.",
        type=str)
    PSNVParser.add_argument(
        "--threads",
        help="Number of threads.",
        type=int)
    PSNVParser.add_argument(
        "-o",
        "--outVCF",
        help="Output VCF File.",
        default=None,
        metavar="OutputVCF")
    PSNVParser.add_argument("inBAM",
                            help="Input BAM, Coordinate-sorted and indexed, "
                            "with BMF Tags included. bmftools runs on unflat"
                            "tened BAMs, but the results are not reliable be"
                            "cause this program assumes as much.",
                            type=str)
    VCFCmpParser = subparsers.add_parser(
        "vcfcmp", description="Compares VCF files.")
    VCFStatsParser = subparsers.add_parser("vcfstats",
                                           description="Gets counts and"
                                           " frequencies for all SNV tr"
                                           "ansitions.")
    DMultiPlexParser = subparsers.add_parser("dmp",
                                             description="Marks, combines, and"
                                             " processes a dataset of fastqs f"
                                             "or further analysis.")
    SNVParser = subparsers.add_parser("snv", description="Call SNVs. Assumes "
                                      "that reads have been collapsed from a "
                                      "family size of at least 2")
    SVParser = subparsers.add_parser("sv",
                                     description="Call structural variants. R"
                                     "equires an Input BAM, coordinate-sorted"
                                     " and indexed, with BMF SV Tags included"
                                     ", and a BED File.")
    SMAParser = subparsers.add_parser(
        "sma",
        description="Tool for splitting a VCF File with multiple alts per"
        " line into a VCF where each line has a unique alt.")
    GetUniqueKmerBedParser = subparsers.add_parser(
        "getuniquekmersbed",
        description=("Tool for selecting kmers which are unique identifiers "
                     "for a region of interest for assembly and produces a"
                     "bed file covering these regions."))
    SNVParser.add_argument("inBAM",
                           help="Input BAM, Coordinate-sorted and indexed, "
                           "with BMF Tags included. bmftools runs on unflat"
                           "tened BAMs, but the results are not reliable be"
                           "cause this program assumes as much.")
    SNVParser.add_argument(
        "--bed",
        "-b",
        help="Full path to bed file.",
        default=None,
        metavar="bedpath")
    SNVParser.add_argument(
        "-o",
        "--outVCF",
        help="Output VCF File.",
        default=None,
        metavar="OutputVCF")
    SNVParser.add_argument(
        "--minBQ",
        help="Minimum Base Quality to consider",
        default=None,
        type=int)
    SNVParser.add_argument(
        "--minMQ",
        help="Minimum Mapping Quality to consider",
        default=None,
        type=int)
    SNVParser.add_argument(
        "--MaxPValue",
        "-p",
        help="Maximum P value to consider, in e notation.",
        type=float,
        default=None)
    SNVParser.add_argument(
        "--keepConsensus",
        "-k",
        default=None)
    SNVParser.add_argument(
        "--logfile",
        help="Name for logfile.",
        default=None)
    SNVParser.add_argument(
        "-r",
        "--ref",
        help="Provide reference fasta.",
        default=None)
    SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",
                           default=None, type=int)
    SNVParser.add_argument(
        "--conf",
        help="Config file to hold this so we don't have to specify.",
        type=str)
    SNVParser.add_argument(
        "--analysisTag", type=str,
        help=("Tag to append to the output VCF before the file extension."
              "Used to delineate analysis pipelines."))
    SNVParser.add_argument(
        "--is-slave",
        help="Whether or not SNVCrawler is slave instance.",
        action="store_true")
    SNVParser.add_argument(
        "--minFracAgreed",
        help=("Minimum fraction of reads in family to agree on a base call "
              "for inclusion in variant calling."),
        type=float)
    VCFStatsParser.add_argument(
        "inVCF",
        help="Input VCF, as created by SNVCrawler.")
    DMultiPlexParser.add_argument(
        "inFqs",
        nargs="+",
        help="Input Fastq Files")
    DMultiPlexParser.add_argument(
        "-i",
        "--indexFq",
        metavar="indexFastq",
        help="Index Fastq",
        required=True)
    DMultiPlexParser.add_argument(
        "-f",
        "--p5Seq",
        metavar="primer5Seq",
        help=("5' primer sequence used by cutadapt (defaults to 'default', "
              "which will run cutadapt to only trim the 3' primer sequence, "
              "if given)"))
    DMultiPlexParser.add_argument(
        "-t",
        "--p3Seq",
        metavar="primer3Seq",
        help=("3' primer sequence used by cutadapt (defaults to 'default', "
              "which will not run cutadapt)"))
    DMultiPlexParser.add_argument(
        "-r", "--rescue", action="store_true",
        help=("Flag to perform barcode rescue with default rescue parameters "
              "for experiments with very low library diversity. Currently "
              "only supported for paired-end reads."))
    alignTagBamParser.add_argument(
        "inFqs",
        nargs="+",
        help="Input Fastq Files")
    alignTagBamParser.add_argument(
        "-b",
        "--bed",
        metavar="bed",
        help=("Bed file not used in the alignment but used in the REalignment"
              " and MawCluster.SVUtils's GetSVRelevantRecordsPaired"))
    alignTagBamParser.add_argument(
        "-r",
        "--ref",
        metavar="ref",
        help="Reference FASTA to align fastqs to")
    alignTagBamParser.add_argument(
        "-a",
        "--aligner",
        metavar="aligner",
        help="Aligner program (e.g. bwa mem or bwa aln)")
    alignTagBamParser.add_argument(
        "-g",
        "--realigner",
        metavar="realigner",
        help="Realigner program (e.g. abra or gatk)")
    alignTagBamParser.add_argument(
        "-p", "--gatkpath",
        metavar="gatk",
        help="Path to the GATK Jar")
    alignTagBamParser.add_argument(
        "-t",
        "--abrapath",
        metavar="abrapath",
        help="Path to the abra realigner program")
    alignTagBamParser.add_argument(
        "-l",
        "--readlength",
        metavar="readlength",
        help="Read length (for abra.KmerSizeEvaluator program",
        type=int)
    TagBamParser.add_argument(
        "inBAM",
        metavar="inBAM",
        help="Untagged Bam, name-sorted")
    TagBamParser.add_argument(
        "--fastq",
        "-f",
        metavar="InFastqs",
        nargs="+",
        help="Tagged, Merged Fastq File(s)")
    TagBamParser.add_argument(
        "-o", "--outfile",
        help=("Path to output file. If not set, defaults to variation "
              "on input bam."),
        type=str)
    SVParser.add_argument(
        'bam',
        help=("Coordinate-Sorted, Indexed Bam File"),
        )
    SVParser.add_argument(
        "-b",
        "--bed",
        help="Path to bedfile.",
        )
    SVParser.add_argument(
        "--minMQ",
        "-m",
        help="Minimum mapping quality for inclusion. Default: 0.",
        type=int)
    SVParser.add_argument(
        "--minBQ",
        help="Minimum base quality for inclusion. Default: 0.",
        type=int)
    SVParser.add_argument(
        "-o",
        "--outTsv",
        help="Output tsv",
        )
    SVParser.add_argument(
        "--minPileupLen",
        "-l",
        help="Length of interval to be considered for call.",
        type=int)
    SVParser.add_argument(
        "--minClustDepth",
        "-d",
        type=int,
        help="Minimum depth for a cluster to be considered for call.")
    SVParser.add_argument(
        "--ref",
        "-r",
        help="Path to reference index.",
        required=True)
    SVParser.add_argument("--insert-distance",
                          "-i",
                          help="Maximum difference between edit distances"
                          " for clustering families together")
    SMAParser.add_argument(
        "inVCF",
        help="Input VCF", type=str)
    SMAParser.add_argument(
        "--outVCF",
        "-o",
        help="Output VCF. If unset, defaults to a modified form of the input.")
    VCFCmpParser.add_argument(
        "queryVCF", help="Query VCF to compare to reference VCF.",
        type=str)
    VCFCmpParser.add_argument(
        "--std", help="Reference VCF for comparing to query VCF.",
        type=str, required=True)
    VCFCmpParser.add_argument(
        "-o", "--outfile", help="Set output file path instead of stdout.")
    VCFCmpParser.add_argument(
        "--check-std",
        help=("If set, check standard VCF for calls in the query VCF rather "
              "than default behavior, which is checking the query VCF for "
              "calls that should be in the standard."),
        action="store_true")
    VCFCmpParser.add_argument(
        "--check-both", action="store_true",
        help=("If set, writes both set comparisons (std vs. query and query "
              "vs. standard) for filenames based on the input file name. "
              "Stdout not supported."))
    GetUniqueKmerBedParser.add_argument(
        "--inbed", "-i",
        metavar="inbed",
        help=("Path to input bed file defining regions where we are "
              "interested in searching for unique kmers."),
        type=str)
    GetUniqueKmerBedParser.add_argument(
        "--ref", "-r",
        metavar="ref",
        help="Path to reference file. (Must be faidx'd)",
        type=str)
    GetUniqueKmerBedParser.add_argument(
        "-k", "--kmer", help=("Length of unique sequence groups (kmers) "
                              "to search for in the reference."),
        metavar="kmer",
        type=int)
    GetUniqueKmerBedParser.add_argument(
        "--padding", "-p",
        help="Distance around the region of interest to pad.",
        type=int)
    GetUniqueKmerBedParser.add_argument(
        "--mismatches", "-m",
        metavar="mismatches",
        help="Number of allowed mismatches.",
        type=int)
    GetUniqueKmerBedParser.add_argument(
        "--outbed", "-o",
        metavar="outbed",
        help="Path to output bed file.",
        type=str)
    FamStatsParser = subparsers.add_parser(
        "famstats", description=("Generate family size stats for a "
                                 "flattened fastq file."))
    FamStatsParser.add_argument(
        "inFq", help="Path to flattened fastq file.", type=str)
    FamStatsParser.add_argument(
        "-o", "--outfile-handle", help="Path to output file. Default: stdout",
        type=argparse.FileType("w"))
    InputQtyParser.add_argument(
        "-n", "--number-of-templates",
        help="Number of template molecules sequenced. "
        "(Both reads in a pair count as 1 total)",
        type=int, required=True)
    InputQtyParser.add_argument(
        "-p", "--paired",
        action="store_true",
        help="Set this flag if the data is paired-end.")
    InputQtyParser.add_argument(
        "-l", "--read-length",
        help="Length of each read.", type=int,
        required=True)
    InputQtyParser.add_argument(
        "--on-target", "-o",
        help="Fraction of reads which are on-target. Default: 0.25 (25%).",
        type=float)
    InputQtyParser.add_argument(
        "--region-size", "-s",
        help="Size of capture region in number of bases.",
        type=int, required=True)
    InputQtyParser.add_argument(
        "--FM", "-f",
        help="Desired mean family size.",
        required=True, type=float)
    InputQtyParser.add_argument(
        "--genome-size", "-g",
        help="Genome size for organism. Defaults to human genome length.",
        type=float)
    InputQtyParser.add_argument(
        "--no-strand-correction",
        help=("Whether or not to count copies of the genome by "
              "strand rather than by dsDNA."),
        action="store_true")
    InputQtyParser.add_argument(
        "--qc-fail",
        help="Fraction of reads not usable due to failing QC. Default: 0.1.",
        type=float)
    InputQtyParser.add_argument(
        "--mean-aligned-fraction",
        help=("Fraction of average read aligned. Default: 0.9"),
        type=float)
    InputQtyParser.add_argument(
        "--mapped-fraction",
        help=("Fraction of reads properly mapped with "
              "MQ != minMQ for variant-calling."),
        type=float)
    InputQtyParser.add_argument(
        "--ligation-efficiency",
        help="Efficiency of ligation of adapters.",
        type=float)
    RescueShadingParser.add_argument(
        "-f", "--fastqs", help="Path to fastq files.",
        nargs="+", type=str)
    RescueShadingParser.add_argument(
        "--head",
        help=("Number of bases from each read with "
              "which to salt the barcode."),
        type=int)
    RescueShadingParser.add_argument(
        "--mm", help="Mismatch limit",
        type=int)
    RescueShadingParser.add_argument(
        "--minFam", "-m", help="Minimum family size for true families.",
        type=int)
    # for each subparser, add_argument for conf.
    # Load default one and then override with config file.
    # Then override any arguments that are not None.

    # set_trace()
    Palin = parser.parse_args()
    Chapman = ArgumentSketcher(Palin, Palin.conf)
    # confDict = load(something)
    commandStr = " ".join(sys.argv)
    print("subcommand: %s" % Chapman['bmfsuites'])
    if(Chapman['bmfsuites'] == "qty"):
        templatesOnTarget = Palin.number_of_templates * Palin.on_target
        if(Palin.paired):
            readsOnTarget = templatesOnTarget * 2
        else:
            readsOnTarget = templatesOnTarget
        basesOnTarget = (readsOnTarget * Palin.read_length *
                         (1 - Chapman['qc_fail']) *
                         Chapman['mean_aligned_fraction'] *
                         Chapman['mapped_fraction'] /
                         Chapman['ligation_efficiency'])
        # Ligation efficiency decreases diversity. Correct for this.
        genomeEquivalentsPerPg = 6.022e23 / (Chapman['genome_size'] * 1e15 *
                                             650 *
                                             Chapman['ligation_efficiency'])
        meanOnTargetCoverage = basesOnTarget / Chapman['region']
        NumCopiesDesired = meanOnTargetCoverage / Palin.FM
        DesiredInputQty = NumCopiesDesired / genomeEquivalentsPerPg
        if(not Palin.no_strand_correction):
            DesiredInputQty /= 2
        print("Desired input qty: %.8fpg" % DesiredInputQty)
    if(Chapman['bmfsuites'] == "psnv"):
        from utilBMF.HTSUtils import GetBMFsnvPopen, parseConfig
        from utilBMF.ErrorHandling import ThisIsMadness
        from subprocess import check_call
        import pysam
        from MawCluster import BCVCF
        from MawCluster.SNVUtils import GetVCFHeader
        if(Chapman['outVCF'] == "default"):
            outVCF = ".".join(Chapman['inBAM'].split(".")[0:-1] +
                              ["FULL", "bmf", "vcf"])
        else:
            outVCF = Chapman['outVCF']
        outHandle = open(outVCF, "w")
        outHandle.write(GetVCFHeader(
            commandStr=commandStr, reference=Chapman["ref"],
            header=pysam.AlignmentFile(Chapman['inBAM'], "rb").header))
        pl("Splitting BAM file by contig.")
        Dispatcher = GetBMFsnvPopen(Chapman['inBAM'], Chapman['bed'],
                                    conf=Chapman['conf'],
                                    threads=Chapman['threads'])
        if(Dispatcher.daemon() != 0):
            raise ThisIsMadness("Dispatcher failed somehow.")
        pl("Shell calls completed without errors.")
        for vcffile in Dispatcher.outstrs.values():
            check_call("cat %s >> %s" % (vcffile, outVCF), shell=True)
        pl("Filtering VCF by bed file. Pre-filter path: %s" % outVCF)
        bedFilteredVCF = BCVCF.FilterVCFFileByBed(
                    outVCF, bedfile=conf['bed'])
        pl("Filtered VCF: %s" % bedFilteredVCF)
        sys.exit(0)
    if(Chapman['bmfsuites'] == "snv"):
        from MawCluster.VCFWriters import SNVCrawler
        from utilBMF.HTSUtils import parseConfig
        from MawCluster.BCVCF import VCFStats
        if(Chapman['analysisTag'] != "default"):
            analysisTag = (Chapman['analysisTag'] + "-" +
                           "-".join([str(Chapman[i]) for i in
                                     ["minMQ", "minBQ", "minFA",
                                      "MaxPValue",
                                      "minFracAgreed"]]))
        else:
            analysisTag = "-".join([str(Chapman[i]) for i in
                                    ["minMQ", "minBQ", "minFA",
                                     "MaxPValue", "minFracAgreed"]])
        if(Chapman['outVCF'] == "default"):
            OutVCF = ".".join(Chapman['inBAM'].split(".")[0:-1] +
                              [analysisTag, "bmf", "vcf"])
        else:
            OutVCF = Chapman['outVCF']
        for pair in Chapman.items():
            pl("Chapman entry. Key: %s. Value: %s." % (pair[0], pair[1]),
               level=logging.DEBUG)
        """
        import cProfile
        import pstats
        pr = cProfile.Profile()
        pr.enable()
        """

        if("bed" in Chapman.keys()):
            print("Reference: %s" % Chapman["reference"])
            # OutVCF = SNVCrawler(Chapman['inBAM'], **Chapman)
            OutVCF = SNVCrawler(Chapman['inBAM'],
                                bed=Chapman["bed"],
                                minMQ=Chapman["minMQ"],
                                minBQ=Chapman["minBQ"],
                                MaxPValue=Chapman["MaxPValue"],
                                keepConsensus=Chapman['keepConsensus'],
                                commandStr=commandStr,
                                reference=Chapman["reference"],
                                reference_is_path=True,
                                minFracAgreed=Chapman["minFracAgreed"],
                                minFA=Chapman["minFA"],
                                OutVCF=OutVCF,
                                writeHeader=(not Chapman['is_slave']))
            OutTable = VCFStats(OutVCF)
        else:
            OutVCF = SNVCrawler(Chapman['inBAM'],
                                minMQ=Chapman["minMQ"],
                                minBQ=Chapman["minBQ"],
                                MaxPValue=Chapman["MaxPValue"],
                                keepConsensus=Chapman['keepConsensus'],
                                commandStr=commandStr,
                                reference=Chapman["reference"],
                                reference_is_path=True,
                                minFracAgreed=Chapman["minFracAgreed"],
                                OutVCF=OutVCF,
                                minFA=Chapman["minFA"],
                                writeHeader=(not Chapman['is_slave']))
            OutTable = VCFStats(OutVCF)
        """
        import cStringIO
        s = cStringIO.StringIO()
        pr.disable()
        sortby = "cumulative"
        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
        ps.print_stats()
        open("cProfile.stats.txt", "w").write(s.getvalue())
        """
        sys.exit(0)
    if(Chapman['bmfsuites'] == "vcfstats"):
        from MawCluster.BCVCF import VCFStats
        OutTable = VCFStats(Chapman['inVCF'])
        sys.exit(0)
    if(Chapman['bmfsuites'] == "dmp"):
        if(len(Chapman['inFqs']) == 2):
            from BMFMain.ProcessingSteps import pairedFastqShades
            OutFastq1, OutFastq2 = pairedFastqShades(
                Chapman['inFqs'][0],
                Chapman['inFqs'][1],
                indexFq=Chapman['indexFq'],
                p3Seq=Chapman['p3Seq'],
                p5Seq=Chapman['p5Seq'],
                rescue=Chapman['rescue'])
            return 0  # sys.exit(main()) returns 0
        elif(len(Chapman['inFqs']) == 1):
            from BMFMain.ProcessingSteps import singleFastqShades
            OutFastq = singleFastqShades(
                Chapman['inFqs'][0],
                indexFq=Chapman['indexFq'],
                p3Seq=Chapman['p3Seq'],
                p5Seq=Chapman['p5Seq'])
            return 0  # sys.exit(main()) returns 0
    if(Chapman['bmfsuites'] == "sv"):
        from utilBMF.ErrorHandling import ThisIsMadness
        from utilBMF.HTSUtils import FacePalm
        from MawCluster.TLC import BMFXLC as CallIntraTrans
        if(Chapman['bed'] == "default"):
            raise ThisIsMadness("Bed file required!")
        else:
            Output = CallIntraTrans(
                Chapman['bam'],
                outfile=Chapman['outTsv'],
                bedfile=Chapman['bed'],
                minMQ=Chapman['minMQ'],
                minBQ=Chapman['minBQ'],
                minClustDepth=Chapman['minClustDepth'],
                minPileupLen=Chapman['minPileupLen'],
                ref=Chapman['ref'],
                insDistance=Chapman['insert_distance'])
        return Output
    if(Chapman['bmfsuites'] == "sma"):
        from MawCluster import BCVCF
        Output = BCVCF.ISplitMultipleAlts(Chapman['inVCF'], Chapman['outVCF'])
        sys.exit(0)
    if(Chapman['bmfsuites'] == "vcfcmp"):
        from MawCluster.BCVCF import (CheckStdCallsForVCFCalls,
                                      CheckVCFForStdCalls)
        if(Chapman['check_both']):
            if(Chapman['outfile'] is None):
                Chapman['outfile'] = Chapman['queryVCF']
            StdForVCF = TrimExt(Chapman['outfile']) + ".VerifyCalls.vcf"
            VCFVsStd = (TrimExt(Chapman['outfile']) +
                        ".CheckForStdConcordance.vcf")
            CheckStdCallsForVCFCalls(Chapman['queryVCF'], Chapman['std'],
                                     outfile=StdForVCF)
            CheckVCFForStdCalls(Chapman['queryVCF'], std=Chapman['std'],
                                outfile=VCFVsStd)
            sys.exit(0)
        if(Chapman['check_std']):
            if(Chapman['outfile'] is not None):
                CheckStdCallsForVCFCalls(Chapman['queryVCF'],
                                         std=Chapman['std'],
                                         outfile=Chapman['outfile'])
            else:
                CheckStdCallsForVCFCalls(Chapman['queryVCF'],
                                         std=Chapman['std'],
                                         outfile=sys.stdout)
            sys.exit(0)
        if(Chapman['outfile'] is not None):
            CheckVCFForStdCalls(Chapman['queryVCF'], std=Chapman['std'],
                                outfile=Chapman['outfile'])
        else:
            CheckVCFForStdCalls(Chapman['queryVCF'], std=Chapman['std'],
                                outfile=sys.stdout)
        sys.exit(0)
    if(Chapman['bmfsuites'] == "getuniquekmersbed"):
        from utilBMF.Uniqueness import KmerFetcher
        KF = KmerFetcher(ref=Chapman['ref'], padding=Chapman['padding'],
                         mismatches=Chapman['mismatches'],
                         k=Chapman['kmer'])
        for line in Chapman['inbed']:
            KF.FillMap("contig", start, stop)
        KF.keys()

    if(Chapman['bmfsuites'] == "famstats"):
        from utilBMF.QC import GetFamSizeStats
        Stats = GetFamSizeStats(Chapman['inFq'],
                                outfile=Chapman['outfile_handle'])
    if(Chapman['bmfsuites'] == "v"):
        from utilBMF.HTSUtils import __version__
        print(__version__)
    if(Chapman['bmfsuites'] == "tagbam"):
        fastqs = Chapman['fastq']
        if(len(fastqs) == 1):
            singleBarcodeTagging(fastqs[0], Chapman['inBAM'],
                                 outputBAM=Chapman['outfile'])
        elif(len(fastqs) == 2):
            pairedBarcodeTagging(fastqs[0], fastqs[1], Chapman['inBAM'],
                                 outBAMFile=Chapman['outfile'])
    if(Chapman['bmfsuites'] == "aligntagbam"):
        from BMFMain.ProcessingSteps import pairedBamProc
        outBAM = pairedBamProc(
            Chapman['inFqs'][0],
            Chapman['inFqs'][1],
            ref=Chapman['ref'],
            bed=Chapman['bed'],
            aligner=Chapman['aligner'],
            realigner=Chapman['realigner'],
            abrapath=Chapman['abrapath'],
            rLen=Chapman['readlength'],
            gatkpath=Chapman['gatkpath'])
        pl("aligntagbam completed succesfully! Final bam is : " + outBAM)
        sys.exit(0)
    if(Chapman['bmfsuites'] == "rsq"):
        from MawCluster.BCFastq import RescueShadingWrapper
        RescueShadingWrapper(Chapman['fastqs'][0],
                             Chapman['fastqs'][1],
                             indexFq=Chapman['fastqs'][2],
                             minFam=Chapman['minFam'],
                             mm=Chapman['mm'],
                             head=Chapman['head'])
    return 0


if(__name__ == "__main__"):
    sys.exit(main())
