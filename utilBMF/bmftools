#!/usr/bin/env python

# Standard library imports
import datetime
import logging
import os
import sys
import uuid
import cython

# BMFTools python imports
from utilBMF.HTSUtils import printlog as pl, TrimExt
from utilBMF.ArgumentSketcher import ArgumentSketcher
from utilBMF.GlobalReporting import SampleMetrics, ReviewDirComponents
from utilBMF.QC import GetAllQCMetrics
from BMFMain import Workflow as wf

from utilBMF.ErrorHandling import ImproperArgumentError, ThisIsHKMadness

global ReferenceDict

"""
bmftools contains various utilities for barcoded reads and for
somatic variant calling. Written to be similar in form to bcftools
and samtools.
"""


def get_args():
    import argparse
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="bmfsuites")
    BamRescue2BamParser = subparsers.add_parser("rescue")
    BamRescue2FqParser = subparsers.add_parser("rescue2fq")
    PipeAlignTagMergeParser = subparsers.add_parser("aligntagmerge")
    SlaveDMPParser = subparsers.add_parser("slavedmp")
    PipeParser = subparsers.add_parser(
        "pipetagbam",
        description="Tags a BAM, taking sam/bam input/output.")
    PipeParser.add_argument(
        "compression",
        help=("First letter determines compression of input."
              "Second letter determines compression of output."
              " (s/b for sam/bam). Add u to emit"
              " uncompressed BAM"))
    PEP8Parser = subparsers.add_parser(
        "pep8",
        description="Command for applying modified PEP8 to this code base.")
    MergePairedAlignmentsParser = subparsers.add_parser(
        "mpa",
        description="Merge duplex read read pairs into a single record each.")
    MainSubparser = subparsers.add_parser(
        "main", description="Run a full pipeline analysis.")
    BedCovParser = subparsers.add_parser(
        "bedcov", description="Calls FastDepthOfCoverage.")
    versionParser = subparsers.add_parser(
        "v", description="Outputs version of BMFTools.")
    versionParser.add_argument(
        "--conf", help="Path to config file, only for compatibility.")
    InputQtyParser = subparsers.add_parser(
        "qty",
        description=("Calculates the quantity of input DNA needed to reach "
                     "a given mean PCR redundancy and a given amount of "
                     "sequencing power."))
    VCFCmpParser = subparsers.add_parser(
        "vcfcmp", description="Compares VCF files.")
    VCFStatsParser = subparsers.add_parser("vcfstats",
                                           description="Gets counts and"
                                           " frequencies for all SNV tr"
                                           "ansitions.")
    MPdemultiplexParser = subparsers.add_parser("dmp", description="Marks,"
                                          "combines, and processes barcoded"
                                          " FASTQs.")
    SMAParser = subparsers.add_parser(
        "sma",
        description="Tool for splitting a VCF File with multiple alts per"
        " line into a VCF where each line has a unique alt.")
    GetUniqueKmerBedParser = subparsers.add_parser(
        "getuniquekmersbed",
        description=("Tool for selecting kmers which are unique identifiers "
                     "for a region of interest for assembly and produces a"
                     "bed file covering these regions."))
    VCFStatsParser.add_argument(
        "inVCF",
        help="Input VCF, as created by SNVCrawler.")
    SMAParser.add_argument(
        "inVCF",
        help="Input VCF", type=str)
    SMAParser.add_argument(
        "--outVCF",
        "-o",
        help="Output VCF. If unset, defaults to a modified form of the input.")
    SMAParser.add_argument(
        "--conf", help=("Path to a config file. If set, load arguments from "
                        "this file, overriding the defaults founds in _bmfto"
                        "ols_helper. Any command-line arguments override thi"
                        "s config file as well."))
    VCFCmpParser.add_argument(
        "queryVCF", help="Query VCF to compare to reference VCF.",
        type=str)
    VCFCmpParser.add_argument(
        "--std", help="Reference VCF for comparing to query VCF.",
        type=str, required=True)
    VCFCmpParser.add_argument(
        "-o", "--outfile", help="Set output file path instead of stdout.")
    VCFCmpParser.add_argument(
        "--check-std",
        help=("If set, check standard VCF for calls in the query VCF rather "
              "than default behavior, which is checking the query VCF for "
              "calls that should be in the standard."),
        action="store_true")
    VCFCmpParser.add_argument(
        "--check-both", action="store_true",
        help=("If set, writes both set comparisons (std vs. query and query "
              "vs. standard) for filenames based on the input file name. "
              "Stdout not supported."))
    VCFCmpParser.add_argument(
        "--conf", help=("Path to a config file. If set, load arguments from "
                        "this file, overriding the defaults founds in _bmfto"
                        "ols_helper. Any command-line arguments override thi"
                        "s config file as well."))
    GetUniqueKmerBedParser.add_argument(
        "--inbed", "-i",
        metavar="inbed",
        help=("Path to input bed file defining regions where we are "
              "interested in searching for unique kmers."),
        type=str,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "--ref", "-r",
        metavar="ref",
        help="Path to reference file. (Must be faidx'd)",
        type=str,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "--aligner", "-a",
        metavar="aligner",
        help="Aligner program (e.g. takes bwa 'mem' or bowtie 'bwt').",
        type=str,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "-k", "--kmer", help=("Length of unique sequence groups (kmers) "
                              "to search for in the reference."),
        metavar="kmer",
        type=int,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "-s", "--seed", help=("Seed length (for bowtie only)"),
        metavar="seed",
        type=int,
        required=False)
    GetUniqueKmerBedParser.add_argument(
        "--padding", "-p",
        help="Distance around the region of interest to pad.",
        type=int,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "--mismatches", "-m",
        metavar="mismatches",
        help="Number of allowed mismatches.",
        type=int,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "--outfile", "-o",
        metavar="outfile",
        help="Path to output bed file.",
        type=str,
        required=True)
    GetUniqueKmerBedParser.add_argument(
        "--conf", help=("Path to a config file. If set, load arguments from "
                        "this file, overriding the defaults founds in _bmfto"
                        "ols_helper. Any command-line arguments override thi"
                        "s config file as well."))
    FamStatsParser = subparsers.add_parser(
        "famstats", description=("Generate family size stats for a "
                                 "flattened fastq file."))
    FamStatsParser.add_argument(
        "inFq", help="Path to flattened fastq file.", type=str)
    FamStatsParser.add_argument(
        "-o", "--outfile-handle", help="Path to output file. Default: stdout",
        type=argparse.FileType("w"))
    FamStatsParser.add_argument(
        "--conf", help=("Path to a config file. If set, load arguments from "
                        "this file, overriding the defaults founds in _bmftoo"
                        "ls_helper. Any command-line arguments override this "
                        "config file as well."))
    InputQtyParser.add_argument(
        "-n", "--number-of-templates",
        help="Number of template molecules sequenced. "
        "(Both reads in a pair count as 1 total)",
        type=int, required=True)
    InputQtyParser.add_argument(
        "-p", "--paired",
        action="store_true",
        help="Set this flag if the data is paired-end.")
    InputQtyParser.add_argument(
        "-l", "--read-length",
        help="Length of each read.", type=int,
        required=True)
    InputQtyParser.add_argument(
        "--on-target", "-o",
        help="Fraction of reads which are on-target. Default: 0.25 (25%).",
        type=float)
    InputQtyParser.add_argument(
        "--region-size", "-s",
        help="Size of capture region in number of bases.",
        type=int, required=True)
    InputQtyParser.add_argument(
        "--FM", "-f",
        help="Desired mean family size.",
        required=True, type=float)
    InputQtyParser.add_argument(
        "--genome-size", "-g",
        help="Genome size for organism. Defaults to human genome length.",
        type=float)
    InputQtyParser.add_argument(
        "--no-strand-correction",
        help=("Whether or not to count copies of the genome by "
              "strand rather than by dsDNA."),
        action="store_true")
    InputQtyParser.add_argument(
        "--qc-fail",
        help="Fraction of reads not usable due to failing QC. Default: 0.1.",
        type=float)
    InputQtyParser.add_argument(
        "--mean-aligned-fraction",
        help=("Fraction of average read aligned. Default: 0.9"),
        type=float)
    InputQtyParser.add_argument(
        "--mapped-fraction",
        help=("Fraction of reads properly mapped with "
              "MQ != minMQ for variant-calling."),
        type=float)
    InputQtyParser.add_argument(
        "--ligation-efficiency",
        help="Efficiency of ligation of adapters.",
        type=float)
    InputQtyParser.add_argument(
        "--conf", help=("Path to a config file. If set, load arguments from "
                        "this file, overriding the defaults founds in _bmftoo"
                        "ls_helper. Any command-line arguments override this "
                        "config file as well."))
    BedCovParser.add_argument(
        "inBAM", help="Path to input BAM.")
    BedCovParser.add_argument(
        "--bed", "-b", help="Path to bed over which to calculate coverage.")
    BedCovParser.add_argument(
        "--threads", "-t", help="Number of threads to use.", type=int)
    BedCovParser.add_argument(
        "--FastDOCPath", "-p", help="Path to FastDOC executable jar.")
    BedCovParser.add_argument(
        "--conf", "-c", help=("Path to config file. Can be used in place of"
                              " any command line arguments."))
    BedCovParser.add_argument(
        "--bed-buffer",
        help=("Number of bases in each direction to pad the bed intervals for"
              " reads bleeding out into surrounding regions."),
        type=int)
    MainSubparser.add_argument(
        'fq',
        help="Provide your fastq file(s).",
        nargs="+",
        metavar=('reads'))
    MainSubparser.add_argument(
        "--indexFq",
        "-i",
        help="Path to index fastq",
        metavar="indexFastq")
    MainSubparser.add_argument(
        '--conf',
        help="Path to config file with settings.")
    MainSubparser.add_argument(
        '-s',
        '--single-end',
        help="Whether the experiment is single-end or not. Default: False",
        type=bool)
    MainSubparser.add_argument(
        '--homing',
        help="Homing sequence for samples.",
        metavar=('HomingSequence'))
    MainSubparser.add_argument(
        '--inline-barcodes',
        help="Use flag if using inline barcodes method.",
        action="store_true")
    MainSubparser.add_argument(
        '-a',
        '--aligner',
        help="Provide your aligner. Default: bwa",
        nargs='?',
        metavar='aligner')
    MainSubparser.add_argument(
        '-o',
        '--opts',
        help="Additional aligner opts. E.g.: --opts '-L 0' ")
    MainSubparser.add_argument(
        '-b',
        '--BAM',
        help="BAM file, if alignment has already run.")
    MainSubparser.add_argument(
        '--bed',
        help="full path to bed file used for variant-calling steps."
             "Can be indicated by the config file.",
        metavar="BEDFile")
    MainSubparser.add_argument(
        '-l',
        '--logfile',
        help="To change default logfile location.")
    MainSubparser.add_argument(
        '-p',
        '--file-prefix',
        help="Set non-default prefix.")
    MainSubparser.add_argument(
        '--minMQ',
        help="Minimum mapping quality for variant call inclusion. "
             "Can be indicated by the config file.",
        type=int)
    MainSubparser.add_argument(
        '--minBQ',
        help="Minimum base quality for variant call inclusion. "
             "Can be indicated by the config file.")
    MainSubparser.add_argument(
        "--minCov",
        help="Minimum coverage for including a position"
        " in the BamToCoverageBed")
    MainSubparser.add_argument(
        "--ref",
        "-r",
        help="Path to reference index. Can be indicated by the config file.")
    MainSubparser.add_argument(
        "--abrapath",
        help="Path to abra jar. Can be indicated by the config file.")
    MainSubparser.add_argument(
        "--p3Seq", help="3' primer sequence for cutadapt.")
    MainSubparser.add_argument(
        "--p5Seq", help="5' primer sequence for cutadapt.")
    MainSubparser.add_argument(
        "--review-dir", help="Prefix for review directory, where important re"
        "sults files will be moved at the end of analysis.")
    MainSubparser.add_argument("--minFA", help="Minimum family members agreed "
                               "on base for inclusion in variant call",
                               type=int)
    MainSubparser.add_argument("--picardpath", help="Path to picard jar. "
                               "Required for calling PicardTools.")
    MainSubparser.add_argument(
        "-g", "--realigner",
        help="Select which indel realigner you wish to use. Supported: abra, "
        "GATK. Set to None to avoid realignment.")
    MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")
    MainSubparser.add_argument("--readLength", help="Read length",
                               type=int)
    MainSubparser.add_argument("--experiment", "-e",
                               help="A comma-joined list of strings with "
                                    "extrainformation for informing "
                                    "analysis. Currently in beta support: "
                                    "ffpe, amplicon.")
    MainSubparser.add_argument(
        "--intelDeflator",
        help="Path to intel deflator. Speeds up abra calls.")
    MainSubparser.add_argument(
        "--sortMem",
        help="Memory to use for sorting fastq files. Default: 6G")
    MainSubparser.add_argument(
        "--bcLen",
        help=("Length of inline barcodes. Ignored for datasets where "
              "the molecular barcode is on a secondary index."),
        type=int)
    MainSubparser.add_argument(
        "--head", help=("Number of bases from the start of reads 1"
                        " and 2 to add to the barcode."),
        type=int)
    MainSubparser.add_argument(
        "--parallel",
        help="Parallelize variant calling activated by this flag.",
        action="store_true")
    MainSubparser.add_argument(
        "--rescue", type=str,
        help="Set to 'true' to add the rescue step to the family merging.")
    MainSubparser.add_argument(
        "--bwapath", help="Path to bwa executable. Default: bwa.")
    MergePairedAlignmentsParser.add_argument(
        "inBAM", help="Path to input BAM. Set to 'stdin' for stdin.")
    MergePairedAlignmentsParser.add_argument(
        "--outBAM", "-o",
        help=("Path to output BAM. Defaults to stdout. "
              "Set to stdout' to be explicit, otherwise."))
    MergePairedAlignmentsParser.add_argument(
        "--coorsort", "-s",
        help=("Use flag to turn on coordinate "
              "sort the merged pair bam output."),
        action="store_true")
    MergePairedAlignmentsParser.add_argument(
        "--conf", help="Path to config file for merging read pairs.")
    MergePairedAlignmentsParser.add_argument(
        "-u", "--uncompressed-bam",
        help="Flag to emit uncompressed bam.", action="store_true")
    MergePairedAlignmentsParser.add_argument(
        "-m", "--sortMem",
        help="sortMem string for sorting, if piping "
        "to a samtools sort. Default: 6G.")
    PEP8Parser.add_argument(
        "--dir",
        help="Path to directory from which to search "
        "recursively for .py/.pyx/.pxd files. Defaults to './'.",
        default="./")
    BamRescue2FqParser.add_argument(
        "inBAM", help="Path to input BAM which has been bmf_bam_sort'd.")
    BamRescue2FqParser.add_argument(
        "-o", "--outBAM", help=("Path to output BAM which has been bmf_bam_"
                                "sort'd. Defaults to 'default'"))
    BamRescue2FqParser.add_argument(
        "--mmlim", "-l", help=("Mismatch limit. Number of barcode "
                               "substitutions to permit when rescuing "
                               "families with barcode errors. Defaults to 2"))
    BamRescue2FqParser.add_argument(
        "--tmpFq", "-f", help="Path to temporary fastq. Default: None.")
    BamRescue2BamParser.add_argument(
        "inBAM", help="Path to input BAM which has been bmf_bam_sort'd.")
    BamRescue2BamParser.add_argument(
        "-o", "--outBAM", help=("Path to output BAM which has been bmf_bam_"
                                "sort'd. Defaults to 'default'"))
    BamRescue2BamParser.add_argument(
        "--mmlim", "-l", help=("Mismatch limit. Number of barcode "
                               "substitutions to permit when rescuing "
                               "families with barcode errors. Defaults to 2"))
    BamRescue2BamParser.add_argument(
        "--threads", "-t", help=("Mismatch limit. Number of barcode "
                               "substitutions to permit when rescuing "
                               "families with barcode errors. Defaults to 2"))
    BamRescue2BamParser.add_argument(
        "--tmpFq", "-f", help="Path to temporary fastq. Default: None.")
    BamRescue2BamParser.add_argument(
        "--ref", "-r", help="Path to reference fasta. Default: None.")
    BamRescue2BamParser.add_argument(
        "--opts",
        help="Options to provide to bwa mem. Defaults to -Y -T 0 -t 4.")
    # for each subparser, add_argument for conf.
    # Load default one and then override with config file.
    # Then override any arguments that are not None.
    return parser.parse_args()


def main():


    # set_trace()
    Palin = get_args()

    # Global Variables
    global Logger
    Logger = logging.getLogger("Primarylogger")
    global Chapman
    if(hasattr(Palin, "conf") is False):
        Palin.conf = None
    Chapman = ArgumentSketcher(Palin, Palin.conf)
    global Metrics
    Metrics = SampleMetrics()
    global ReviewDirFiles
    ReviewDirFiles = ReviewDirComponents()

    # BEGIN SETUP LOGGING #
    #
    # Declare logging style
    dateStr = datetime.datetime.now().strftime("%Y-%b-%d,%H-%m-%S")
    # Begin logging
    # Grabs first non "bmftools" and non-flag field.
    basename = "bmftools_%s" % Chapman('bmfsuites')
    logbasename = basename
    if(Chapman['logfile'] != "default"):
        logfile = Chapman['logfile']
    else:
        logfile = (os.getcwd() + "/" +
                   logbasename.split('.')[0] +
                   '.log')
    if(Chapman['file_prefix'] != "default"):
        logfile = os.getcwd() + "/" + Chapman['file_prefix'] + ".log"
    if(os.path.isfile(logfile)):
        logfile = TrimExt(logfile) + "." + \
                  str(uuid.uuid4().get_hex().upper()[0:6]) + ".log"

    # Logger which holds both console and file loggers
    Logger.setLevel(logging.DEBUG)

    # Console handler - outputs to console as stderr
    ch = logging.StreamHandler(stream=sys.stderr)
    ch.setLevel(logging.DEBUG)

    # create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    Logger.addHandler(ch)

    # File logger - outputs to log file.

    # END SETUP LOGGING #

    commandStr = " ".join(sys.argv)
    subcommand = Chapman['bmfsuites']
    if(subcommand in ["main", "snv", "psnv", "getuniquekmersbed"] or
       Chapman['create_log'] is True):
        fl = logging.FileHandler(filename=logfile)
        fl.setFormatter(formatter)
        fl.setLevel(logging.DEBUG)
        Logger.addHandler(fl)
    else:
        sys.stderr.write("Logging skipped for subcommand. Override with create_log"
                     " == True if you want to create a log next time.\n")
    sys.stderr.write("Now executable bmftools subcommand %s\n" % subcommand)
    if(subcommand == "qty"):
        templatesOnTarget = Palin.number_of_templates * Palin.on_target
        if(Palin.paired):
            readsOnTarget = templatesOnTarget * 2
        else:
            readsOnTarget = templatesOnTarget
        basesOnTarget = (readsOnTarget * Palin.read_length *
                         (1 - Chapman['qc_fail']) *
                         Chapman['mean_aligned_fraction'] *
                         Chapman['mapped_fraction'] /
                         Chapman['ligation_efficiency'])
        # Ligation efficiency decreases diversity. Correct for this.
        genomeEquivalentsPerPg = 6.022e23 / (Chapman['genome_size'] * 1e15 *
                                             650 *
                                             Chapman['ligation_efficiency'])
        meanOnTargetCoverage = basesOnTarget / Chapman['region']
        NumCopiesDesired = meanOnTargetCoverage / Palin.FM
        DesiredInputQty = NumCopiesDesired / genomeEquivalentsPerPg
        if(not Palin.no_strand_correction):
            DesiredInputQty /= 2
        print("Desired input qty: %.8fpg" % DesiredInputQty)
    elif(subcommand == "vcfstats"):
        from MawCluster.BCVCF import VCFStats
        OutTable = VCFStats(Chapman['inVCF'])
        sys.exit(0)
    elif(subcommand == "dmp"):
        from utilBMF.DMPUtils import splitMPdmp as DMP
        outFq1, outFq2 = DMP(
            Chapman['inFqs'],
            indexFq=Chapman['indexFq'],
            p3Seq=Chapman['p3Seq'],
            p5Seq=Chapman['p5Seq'],
            prefixLength=Chapman['prefixLength'],
            hpLimit=Chapman['hpLimit'],
            ncpus=Chapman['ncpus'],
            head=Chapman['head'],
            cutadapt=Chapman['cutadapt'],
            bcLen=Chapman['bcLen'],
            inline=Chapman['inline'],
            skipNucs=Chapman['skipNucs'],
            homing=Chapman['homing'],
            profile=Chapman['profile'])
        pl("Demultiplexing, marking, consildating, and compression complete"
            "new fastqs are %s and %s" % (outFq1, outFq2))
        return 0  # sys.exit(main()) returns 0
    elif(subcommand == "sma"):
        from MawCluster import BCVCF
        Output = BCVCF.ISplitMultipleAlts(Chapman['inVCF'], Chapman['outVCF'])
        sys.exit(0)
    elif(subcommand == "vcfcmp"):
        from MawCluster.BCVCF import (CheckStdCallsForVCFCalls,
                                      CheckVCFForStdCalls)
        if(Chapman['check_both']):
            if(Chapman['outfile'] is None):
                Chapman['outfile'] = Chapman['queryVCF']
            StdForVCF = TrimExt(Chapman['outfile']) + ".VerifyCalls.vcf"
            VCFVsStd = (TrimExt(Chapman['outfile']) +
                        ".CheckForStdConcordance.vcf")
            CheckStdCallsForVCFCalls(Chapman['queryVCF'], Chapman['std'],
                                     outfile=StdForVCF)
            CheckVCFForStdCalls(Chapman['queryVCF'], std=Chapman['std'],
                                outfile=VCFVsStd)
            sys.exit(0)
        if(Chapman['check_std']):
            if(Chapman['outfile'] is not None):
                CheckStdCallsForVCFCalls(Chapman['queryVCF'],
                                         std=Chapman['std'],
                                         outfile=Chapman['outfile'])
            else:
                CheckStdCallsForVCFCalls(Chapman['queryVCF'],
                                         std=Chapman['std'],
                                         outfile=sys.stdout)
            sys.exit(0)
        if(Chapman['outfile'] is not None):
            CheckVCFForStdCalls(Chapman['queryVCF'], std=Chapman['std'],
                                outfile=Chapman['outfile'])
        else:
            CheckVCFForStdCalls(Chapman['queryVCF'], std=Chapman['std'],
                                outfile=sys.stdout)
        sys.exit(0)
    elif(subcommand == "getuniquekmersbed"):
        from utilBMF.Uniqueness import KmerFetcher
        from utilBMF.HTSUtils import ParseBed
        from subprocess import check_call
        if Chapman['aligner'] == 'bwt':
            raise ThisIsHKMadness("Bowtie not recommended for use due to "
                                  "identified bugs.")
        if Chapman['aligner'] == 'mem' and 'seed' in Chapman.getkeys():
            pl("WARNING: Bwa mem does not use the seed parameter, ignoring " +
               str(Chapman['seed']) + ".", level=logging.WARNING)
        pl("Grabbing regions in input bed file that contain uniquely mapping "
           "kmers.")
        # Loads unique kmers from each line of the (padded) bed file into a
        # KmerFetcher HashMap object (key=inbed region, value=list of RefKmer
        # objects) by running GetUniqueKmers (runs alignment on a fastq file
        # of kmers built from the padded bed regions & parses its output)
        KF = KmerFetcher(ref=Chapman['ref'], padding=Chapman['padding'],
                         mismatches=Chapman['mismatches'],
                         minMQ=Chapman['minMQ'], k=Chapman['kmer'],
                         aligner=Chapman['aligner'])

        bedlines = ParseBed(Chapman['inbed'])
        for bedlineList in bedlines:
            pl("Analyzing kmers from bed region " + bedlineList[0] + ": " +
               str(bedlineList[1]) + " - " + str(bedlineList[2]) +
               " with padding of " + str(Chapman['padding']))
            # Populate unique KmerObjects per region
            KF.FillMap(bedlineList)

        # Convert unique kmers to sorted/merged bedfile within the boundaries
        # of the original bed
        outList = KF.GetIntervalsFromMap() #This returns continuous starts
        # Create the kmer start positions only bed file
        pl("Converting " + str(len(outList)) + " continuous intervals into  bed "
                                               "files.")
        KF.ConvertIntervalsToBed(outList, inFile=Chapman['inbed'],
                                 outFile=Chapman['outfile'][:-3] +
                                         "KmerStarts.bed",
                                 startsOnly=True)
        # Create the full kmer region bed file
        KF.ConvertIntervalsToBed(outList, inFile=Chapman['inbed'],
                                 outFile=Chapman['outfile'][:-3] +
                                         "fullKmer.bed",
                                 startsOnly=False)

    elif(subcommand == "famstats"):
        from utilBMF.QC import GetFamSizeStats
        Stats = GetFamSizeStats(Chapman['inFq'],
                                outfile=Chapman['outfile_handle'])
    elif subcommand == "v":
        from utilBMF.HTSUtils import __version__
        print(__version__)
        return 0
    elif(subcommand == "main"):
        print("Beginning something!")
        if(Chapman['single_end'] is True):
            pl("Single-end analysis chosen.")
            raise NotImplementedError("Single-end analysis not currently "
                                      "supported. Soon!")
        else:
            pl("Paired-end analysis chosen.")
            pl("Beginning fastq processing.")
            print("Repr of Chapman['fq']: %s" % repr(Chapman['fq']))
            trimfq1, trimfq2 = wf.pairedFastqShades(
                Chapman['fq'][0], Chapman['fq'][1],
                indexFq=Chapman['indexFq'],
                p3Seq=Chapman['p3Seq'], p5Seq=Chapman['p5Seq'],
                inline_barcodes=Chapman['inline_barcodes'],
                homing=Chapman['homing'],
                bcLen=Chapman['bcLen'], head=Chapman['head'],
                rescue=Chapman['rescue'],
                sortMem=Chapman['sortMem'])
            procSortedBam = wf.pairedBamProc(
                trimfq1, trimfq2,
                aligner=Chapman['aligner'], ref=Chapman['ref'],
                bed=Chapman['bed'],
                abrapath=Chapman['abrapath'],
                picardpath=Chapman['picardpath'],
                dbsnp=Chapman['dbsnp'],
                gatkpath=Chapman['gatkpath'],
                realigner=Chapman('realigner'),
                rLen=Chapman['readLength'],
                opts=Chapman['opts'],
                kmers_precomputed=Chapman['kmers_precomputed'],
                intelDeflator=Chapman['intelDeflator'],
                sortMem=Chapman['sortMem'],
                bwapath=Chapman['bwapath'])
            VCFOutDict = wf.pairedVCFProc(
                procSortedBam,
                ref=Chapman['ref'],
                opts=Chapman['opts'],
                bed=Chapman['bed'],
                minMQ=Chapman['minMQ'],
                minBQ=Chapman['minBQ'],
                commandStr=" ".join(sys.argv),
                minFA=Chapman['minFA'], minFracAgreed=Chapman['minFracAgreed'],
                exp=Chapman['experiment'], conf=Chapman['conf'],
                parallel=Chapman['parallel'])
            QCMetrics = GetAllQCMetrics(procSortedBam, bedfile=Chapman['bed'],
                                        minFM=Chapman['minFM'],
                                        FastDOCPath=Chapman["FastDOCPath"],
                                        minMQ=Chapman("minMQ"))
            pl("Last stop! Watch your step.")
    elif(subcommand == "mpa"):
        from utilBMF.MPA import MPA2Bam
        if(Chapman('outBAM') in [None, "default", "stdout"]):
            Chapman['outBAM'] = "-"  # Prints to stdout.
        outBAM = MPA2Bam(Chapman['inBAM'], outBAM=Chapman['outBAM'],
                         u=Chapman('uncompressed_bam'),
                         coorsort=Chapman('coorsort'),
                         sortMem=Chapman('sortMem'))
    elif(subcommand == "rescue2fq"):
        from MawCluster.BCBam import pBamRescue as BamRescue
        if Chapman['tmpFq'] is None:
            Chapman['tmpFq'] = TrimExt(Chapman['inBAM']) + ".tmp.ra.fastq"
        out_bam = BamRescue(Chapman['inBAM'], Chapman['outBAM'], Chapman['tmpFq'],
                            Chapman['mmlim'])
        sys.stderr.write("Successfully rescued bam. Output BAM: "
                         "%s. Output fastq: %s.\n" % (Chapman['outBAM'],
                                                      Chapman['tmpFq']))
    elif(subcommand == "rescue"):
        from MawCluster.BCBam import BamRescueFull
        if Chapman['tmpFq'] is None:
            Chapman['tmpFq'] = TrimExt(Chapman['inBAM']) + ".tmp.ra.fastq"
        if Chapman['outBAM'] is None:
            Chapman['outBAM'] = TrimExt(Chapman['inBAM']) + ".tmp.ra.bam"
        outBam = BamRescueFull(Chapman['inBAM'], Chapman['outBAM'],
                               Chapman['ref'],
                               opts=Chapman['opts'],
                               mmlim=int(Chapman['mmlim']),
                               threads=int(Chapman['threads']))

    pl("Successful completion of subcommand %s." % subcommand +
       "\nSample Metrics: %s" % repr(Metrics))
    return 0


if(__name__ == "__main__"):
    sys.exit(main())
