/* Generated by Cython 0.22 */

#define PY_SSIZE_T_CLEAN
#ifndef CYTHON_USE_PYLONG_INTERNALS
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 0
#else
#include "pyconfig.h"
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 1
#else
#define CYTHON_USE_PYLONG_INTERNALS 0
#endif
#endif
#endif
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_22"
#include <stddef.h>
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
#define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX < 0x030400a1 && !defined(Py_TPFLAGS_HAVE_FINALIZE)
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
  #define __Pyx_PyFrozenSet_Size(s)         PyObject_Size(s)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ? \
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
  #define __Pyx_PyFrozenSet_Size(s)         PySet_Size(s)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
   a quiet NaN. */
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#define __Pyx_void_to_None(void_result) (void_result, Py_INCREF(Py_None), Py_None)
#ifdef __cplusplus
template<typename T>
void __Pyx_call_destructor(T* x) {
    x->~T();
}
template<typename T>
class __Pyx_FakeReference {
  public:
    __Pyx_FakeReference() : ptr(NULL) { }
    __Pyx_FakeReference(T& ref) : ptr(&ref) { }
    T *operator->() { return ptr; }
    operator T&() { return *ptr; }
  private:
    T *ptr;
};
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__utilBMF__bmftools
#define __PYX_HAVE_API__utilBMF__bmftools
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (    \
    (sizeof(type) < sizeof(Py_ssize_t))  ||             \
    (sizeof(type) > sizeof(Py_ssize_t) &&               \
          likely(v < (type)PY_SSIZE_T_MAX ||            \
                 v == (type)PY_SSIZE_T_MAX)  &&         \
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||       \
                                v == (type)PY_SSIZE_T_MIN)))  ||  \
    (sizeof(type) == sizeof(Py_ssize_t) &&              \
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||        \
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "utilBMF/bmftools",
};

/*--- Type declarations ---*/

/* --- Runtime support code (head) --- */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {                            \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_XDECREF(tmp);                              \
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {                             \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_DECREF(tmp);                               \
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name);

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o,n,NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

static CYTHON_INLINE PyObject* __Pyx_PyObject_GetSlice(
        PyObject* obj, Py_ssize_t cstart, Py_ssize_t cstop,
        PyObject** py_start, PyObject** py_stop, PyObject** py_slice,
        int has_cstart, int has_cstop, int wraparound);

#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) : \
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) : \
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

#include <string.h>

static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);

#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
#else
#define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

static int __Pyx_Print(PyObject*, PyObject *, int);
#if CYTHON_COMPILING_IN_PYPY || PY_MAJOR_VERSION >= 3
static PyObject* __pyx_print = 0;
static PyObject* __pyx_print_kwargs = 0;
#endif

static int __Pyx_PrintOne(PyObject* stream, PyObject *o);

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

static int __Pyx_check_binary_version(void);

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'utilBMF.bmftools' */
#define __Pyx_MODULE_NAME "utilBMF.bmftools"
int __pyx_module_is_main_utilBMF__bmftools = 0;

/* Implementation of 'utilBMF.bmftools' */
static PyObject *__pyx_pf_7utilBMF_8bmftools_main(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static char __pyx_k_a[] = "-a";
static char __pyx_k_b[] = "-b";
static char __pyx_k_c[] = "-c";
static char __pyx_k_d[] = "-d";
static char __pyx_k_e[] = "-e";
static char __pyx_k_f[] = "-f";
static char __pyx_k_g[] = "-g";
static char __pyx_k_i[] = "-i";
static char __pyx_k_k[] = "-k";
static char __pyx_k_l[] = "-l";
static char __pyx_k_m[] = "-m";
static char __pyx_k_n[] = "-n";
static char __pyx_k_o[] = "-o";
static char __pyx_k_p[] = "-p";
static char __pyx_k_r[] = "-r";
static char __pyx_k_s[] = "-s";
static char __pyx_k_t[] = "-t";
static char __pyx_k_v[] = "v";
static char __pyx_k_w[] = "w";
static char __pyx_k_FM[] = "--FM";
static char __pyx_k_fq[] = "fq";
static char __pyx_k_mm[] = "--mm";
static char __pyx_k_os[] = "os";
static char __pyx_k_pl[] = "pl";
static char __pyx_k_sv[] = "sv";
static char __pyx_k_BAM[] = "--BAM";
static char __pyx_k__36[] = "+";
static char __pyx_k_bam[] = "bam";
static char __pyx_k_bed[] = "--bed";
static char __pyx_k_dmp[] = "dmp";
static char __pyx_k_end[] = "end";
static char __pyx_k_i_2[] = "i";
static char __pyx_k_now[] = "now";
static char __pyx_k_qty[] = "qty";
static char __pyx_k_ref[] = "--ref";
static char __pyx_k_rsq[] = "rsq";
static char __pyx_k_sma[] = "sma";
static char __pyx_k_snv[] = "snv";
static char __pyx_k_std[] = "--std";
static char __pyx_k_sys[] = "sys";
static char __pyx_k__117[] = "?";
static char __pyx_k__146[] = "-";
static char __pyx_k_argv[] = "argv";
static char __pyx_k_conf[] = "--conf";
static char __pyx_k_dest[] = "dest";
static char __pyx_k_exit[] = "exit";
static char __pyx_k_file[] = "file";
static char __pyx_k_gatk[] = "gatk";
static char __pyx_k_head[] = "--head";
static char __pyx_k_help[] = "help";
static char __pyx_k_inFq[] = "inFq";
static char __pyx_k_kmer[] = "--kmer";
static char __pyx_k_main[] = "main";
static char __pyx_k_name[] = "__name__";
static char __pyx_k_opts[] = "--opts";
static char __pyx_k_path[] = "path";
static char __pyx_k_psnv[] = "psnv";
static char __pyx_k_test[] = "__test__";
static char __pyx_k_type[] = "type";
static char __pyx_k_Palin[] = "Palin";
static char __pyx_k_bcLen[] = "--bcLen";
static char __pyx_k_bed_2[] = "bed";
static char __pyx_k_fastq[] = "--fastq";
static char __pyx_k_inBAM[] = "inBAM";
static char __pyx_k_inFqs[] = "inFqs";
static char __pyx_k_inVCF[] = "inVCF";
static char __pyx_k_inbed[] = "--inbed";
static char __pyx_k_minBQ[] = "--minBQ";
static char __pyx_k_minFA[] = "--minFA";
static char __pyx_k_minMQ[] = "--minMQ";
static char __pyx_k_nargs[] = "nargs";
static char __pyx_k_p3Seq[] = "--p3Seq";
static char __pyx_k_p5Seq[] = "--p5Seq";
static char __pyx_k_print[] = "print";
static char __pyx_k_reads[] = "reads";
static char __pyx_k_ref_2[] = "ref";
static char __pyx_k_Logger[] = "Logger";
static char __pyx_k_action[] = "action";
static char __pyx_k_bedcov[] = "bedcov";
static char __pyx_k_conf_2[] = "conf";
static char __pyx_k_fastqs[] = "--fastqs";
static char __pyx_k_homing[] = "--homing";
static char __pyx_k_import[] = "__import__";
static char __pyx_k_kmer_2[] = "kmer";
static char __pyx_k_main_2[] = "__main__";
static char __pyx_k_minCov[] = "--minCov";
static char __pyx_k_minFam[] = "--minFam";
static char __pyx_k_ospath[] = "ospath";
static char __pyx_k_outTsv[] = "--outTsv";
static char __pyx_k_outVCF[] = "--outVCF";
static char __pyx_k_outbed[] = "--outbed";
static char __pyx_k_paired[] = "--paired";
static char __pyx_k_parser[] = "parser";
static char __pyx_k_rescue[] = "--rescue";
static char __pyx_k_tagbam[] = "tagbam";
static char __pyx_k_vcfcmp[] = "vcfcmp";
static char __pyx_k_BEDFile[] = "BEDFile";
static char __pyx_k_Chapman[] = "Chapman";
static char __pyx_k_Metrics[] = "Metrics";
static char __pyx_k_TrimExt[] = "TrimExt";
static char __pyx_k_aligner[] = "--aligner";
static char __pyx_k_bedpath[] = "bedpath";
static char __pyx_k_dateStr[] = "dateStr";
static char __pyx_k_default[] = "default";
static char __pyx_k_inbed_2[] = "inbed";
static char __pyx_k_indexFq[] = "--indexFq";
static char __pyx_k_logfile[] = "--logfile";
static char __pyx_k_logging[] = "logging";
static char __pyx_k_metavar[] = "metavar";
static char __pyx_k_outfile[] = "--outfile";
static char __pyx_k_padding[] = "--padding";
static char __pyx_k_qc_fail[] = "--qc-fail";
static char __pyx_k_sortMem[] = "--sortMem";
static char __pyx_k_threads[] = "--threads";
static char __pyx_k_FileType[] = "FileType";
static char __pyx_k_InFastqs[] = "InFastqs";
static char __pyx_k_SVParser[] = "SVParser";
static char __pyx_k_abrapath[] = "--abrapath";
static char __pyx_k_argparse[] = "argparse";
static char __pyx_k_basename[] = "basename";
static char __pyx_k_datetime[] = "datetime";
static char __pyx_k_famstats[] = "famstats";
static char __pyx_k_gatkpath[] = "--gatkpath";
static char __pyx_k_idxFastq[] = "--idxFastq";
static char __pyx_k_is_slave[] = "--is-slave";
static char __pyx_k_outbed_2[] = "outbed";
static char __pyx_k_parallel[] = "--parallel";
static char __pyx_k_printlog[] = "printlog";
static char __pyx_k_queryVCF[] = "queryVCF";
static char __pyx_k_required[] = "required";
static char __pyx_k_strftime[] = "strftime";
static char __pyx_k_vcfstats[] = "vcfstats";
static char __pyx_k_Input_VCF[] = "Input VCF";
static char __pyx_k_MaxPValue[] = "--MaxPValue";
static char __pyx_k_OutputVCF[] = "OutputVCF";
static char __pyx_k_SMAParser[] = "SMAParser";
static char __pyx_k_SNVParser[] = "SNVParser";
static char __pyx_k_aligner_2[] = "aligner";
static char __pyx_k_bmfsuites[] = "bmfsuites";
static char __pyx_k_check_std[] = "--check-std";
static char __pyx_k_getLogger[] = "getLogger";
static char __pyx_k_on_target[] = "--on-target";
static char __pyx_k_realigner[] = "--realigner";
static char __pyx_k_Output_tsv[] = "Output tsv";
static char __pyx_k_PSNVParser[] = "PSNVParser";
static char __pyx_k_abrapath_2[] = "abrapath";
static char __pyx_k_add_parser[] = "add_parser";
static char __pyx_k_basename_s[] = "basename: %s";
static char __pyx_k_bed_buffer[] = "--bed-buffer";
static char __pyx_k_check_both[] = "--check-both";
static char __pyx_k_experiment[] = "--experiment";
static char __pyx_k_indexFastq[] = "indexFastq";
static char __pyx_k_mismatches[] = "--mismatches";
static char __pyx_k_parse_args[] = "parse_args";
static char __pyx_k_picardpath[] = "--picardpath";
static char __pyx_k_primer3Seq[] = "primer3Seq";
static char __pyx_k_primer5Seq[] = "primer5Seq";
static char __pyx_k_readLength[] = "--readLength";
static char __pyx_k_readlength[] = "--readlength";
static char __pyx_k_review_dir[] = "--review-dir";
static char __pyx_k_single_end[] = "--single-end";
static char __pyx_k_store_true[] = "store_true";
static char __pyx_k_subparsers[] = "subparsers";
static char __pyx_k_FastDOCPath[] = "--FastDOCPath";
static char __pyx_k_Index_Fastq[] = "Index Fastq";
static char __pyx_k_Read_length[] = "Read length";
static char __pyx_k_Y_b_d_H_m_S[] = "%Y-%b-%d,%H-%m-%S";
static char __pyx_k_aligntagbam[] = "aligntagbam";
static char __pyx_k_analysisTag[] = "--analysisTag";
static char __pyx_k_description[] = "description";
static char __pyx_k_file_prefix[] = "--file-prefix";
static char __pyx_k_genome_size[] = "--genome-size";
static char __pyx_k_read_length[] = "--read-length";
static char __pyx_k_realigner_2[] = "realigner";
static char __pyx_k_region_size[] = "--region-size";
static char __pyx_k_BedCovParser[] = "BedCovParser";
static char __pyx_k_TagBamParser[] = "TagBamParser";
static char __pyx_k_VCFCmpParser[] = "VCFCmpParser";
static char __pyx_k_add_argument[] = "add_argument";
static char __pyx_k_minPileupLen[] = "--minPileupLen";
static char __pyx_k_mismatches_2[] = "mismatches";
static char __pyx_k_readlength_2[] = "readlength";
static char __pyx_k_MainSubparser[] = "MainSubparser";
static char __pyx_k_Primarylogger[] = "Primarylogger";
static char __pyx_k_SampleMetrics[] = "SampleMetrics";
static char __pyx_k_intelDeflator[] = "--intelDeflator";
static char __pyx_k_keepConsensus[] = "--keepConsensus";
static char __pyx_k_minClustDepth[] = "--minClustDepth";
static char __pyx_k_minFracAgreed[] = "--minFracAgreed";
static char __pyx_k_versionParser[] = "versionParser";
static char __pyx_k_ArgumentParser[] = "ArgumentParser";
static char __pyx_k_FamStatsParser[] = "FamStatsParser";
static char __pyx_k_HomingSequence[] = "HomingSequence";
static char __pyx_k_InputQtyParser[] = "InputQtyParser";
static char __pyx_k_Mismatch_limit[] = "Mismatch limit";
static char __pyx_k_ReviewDirFiles[] = "ReviewDirFiles";
static char __pyx_k_VCFStatsParser[] = "VCFStatsParser";
static char __pyx_k_add_subparsers[] = "add_subparsers";
static char __pyx_k_indelRealigner[] = "--indelRealigner";
static char __pyx_k_outfile_handle[] = "--outfile-handle";
static char __pyx_k_Output_VCF_File[] = "Output VCF File.";
static char __pyx_k_Path_to_bedfile[] = "Path to bedfile.";
static char __pyx_k_inline_barcodes[] = "--inline-barcodes";
static char __pyx_k_insert_distance[] = "--insert-distance";
static char __pyx_k_mapped_fraction[] = "--mapped-fraction";
static char __pyx_k_ArgumentSketcher[] = "ArgumentSketcher";
static char __pyx_k_DMultiPlexParser[] = "DMultiPlexParser";
static char __pyx_k_MawCluster_BCBam[] = "MawCluster.BCBam";
static char __pyx_k_Name_for_logfile[] = "Name for logfile.";
static char __pyx_k_utilBMF_HTSUtils[] = "utilBMF.HTSUtils";
static char __pyx_k_utilBMF_bmftools[] = "utilBMF.bmftools";
static char __pyx_k_Input_Fastq_Files[] = "Input Fastq Files";
static char __pyx_k_Number_of_threads[] = "Number of threads.";
static char __pyx_k_Path_to_input_BAM[] = "Path to input BAM.";
static char __pyx_k_alignTagBamParser[] = "alignTagBamParser";
static char __pyx_k_getuniquekmersbed[] = "getuniquekmersbed";
static char __pyx_k_Compares_VCF_files[] = "Compares VCF files.";
static char __pyx_k_Parallel_SNV_calls[] = "Parallel SNV calls.";
static char __pyx_k_Length_of_each_read[] = "Length of each read.";
static char __pyx_k_Path_to_fastq_files[] = "Path to fastq files.";
static char __pyx_k_Path_to_index_fastq[] = "Path to index fastq";
static char __pyx_k_RescueShadingParser[] = "RescueShadingParser";
static char __pyx_k_ReviewDirComponents[] = "ReviewDirComponents";
static char __pyx_k_ligation_efficiency[] = "--ligation-efficiency";
static char __pyx_k_number_of_templates[] = "--number-of-templates";
static char __pyx_k_Path_to_the_GATK_Jar[] = "Path to the GATK Jar";
static char __pyx_k_Rescue_fastq_shading[] = "Rescue fastq shading.";
static char __pyx_k_no_strand_correction[] = "--no-strand-correction";
static char __pyx_k_pairedBarcodeTagging[] = "pairedBarcodeTagging";
static char __pyx_k_singleBarcodeTagging[] = "singleBarcodeTagging";
static char __pyx_k_Full_path_to_bed_file[] = "Full path to bed file.";
static char __pyx_k_Path_to_GATK_jar_v1_6[] = "Path to GATK jar. (v1.6)";
static char __pyx_k_mean_aligned_fraction[] = "--mean-aligned-fraction";
static char __pyx_k_GetUniqueKmerBedParser[] = "GetUniqueKmerBedParser";
static char __pyx_k_Set_non_default_prefix[] = "Set non-default prefix.";
static char __pyx_k_Path_to_output_bed_file[] = "Path to output bed file.";
static char __pyx_k_Path_to_reference_index[] = "Path to reference index.";
static char __pyx_k_Provide_reference_fasta[] = "Provide reference fasta.";
static char __pyx_k_utilBMF_GlobalReporting[] = "utilBMF.GlobalReporting";
static char __pyx_k_Desired_mean_family_size[] = "Desired mean family size.";
static char __pyx_k_Number_of_threads_to_use[] = "Number of threads to use.";
static char __pyx_k_Untagged_Bam_name_sorted[] = "Untagged Bam, name-sorted";
static char __pyx_k_utilBMF_ArgumentSketcher[] = "utilBMF.ArgumentSketcher";
static char __pyx_k_Calls_FastDepthOfCoverage[] = "Calls FastDepthOfCoverage.";
static char __pyx_k_Provide_your_fastq_file_s[] = "Provide your fastq file(s).";
static char __pyx_k_Tagged_Merged_Fastq_File_s[] = "Tagged, Merged Fastq File(s)";
static char __pyx_k_Homing_sequence_for_samples[] = "Homing sequence for samples.";
static char __pyx_k_Outputs_version_of_BMFTools[] = "Outputs version of BMFTools.";
static char __pyx_k_Number_of_allowed_mismatches[] = "Number of allowed mismatches.";
static char __pyx_k_Path_to_flattened_fastq_file[] = "Path to flattened fastq file.";
static char __pyx_k_Run_a_full_pipeline_analysis[] = "Run a full pipeline analysis.";
static char __pyx_k_Minimum_family_agreed_on_base[] = "Minimum family agreed on base.";
static char __pyx_k_3_primer_sequence_for_cutadapt[] = "3' primer sequence for cutadapt.";
static char __pyx_k_5_primer_sequence_for_cutadapt[] = "5' primer sequence for cutadapt.";
static char __pyx_k_Path_to_FastDOC_executable_jar[] = "Path to FastDOC executable jar.";
static char __pyx_k_Gets_counts_and_frequencies_for[] = "Gets counts and frequencies for all SNV transitions.";
static char __pyx_k_Input_BAM_Coordinate_sorted_and[] = "Input BAM, Coordinate-sorted and indexed, with BMF Tags included. bmftools runs on unflattened BAMs, but the results are not reliable because this program assumes as much.";
static char __pyx_k_Maximum_difference_between_edit[] = "Maximum difference between edit distances for clustering families together";
static char __pyx_k_Memory_to_use_for_sorting_fastq[] = "Memory to use for sorting fastq files. Default: 6G";
static char __pyx_k_Output_VCF_If_unset_defaults_to[] = "Output VCF. If unset, defaults to a modified form of the input.";
static char __pyx_k_Path_to_config_file_Can_be_used[] = "Path to config file. Can be used in place of any command line arguments.";
static char __pyx_k_Path_to_input_bed_file_defining[] = "Path to input bed file defining regions where we are interested in searching for unique kmers.";
static char __pyx_k_Path_to_picard_jar_Required_for[] = "Path to picard jar. Required for calling PicardTools.";
static char __pyx_k_Reference_FASTA_to_align_fastqs[] = "Reference FASTA to align fastqs to";
static char __pyx_k_Set_output_file_path_instead_of[] = "Set output file path instead of stdout.";
static char __pyx_k_Tag_a_BAM_file_with_appropriate[] = "Tag a BAM file with appropriate information from merged fastq files.";
static char __pyx_k_Tag_to_append_to_the_output_VCF[] = "Tag to append to the output VCF before the file extension.Used to delineate analysis pipelines.";
static char __pyx_k_yggdrasil_workspace_BMFTools_ut[] = "/yggdrasil/workspace/BMFTools/utilBMF/bmftools";
static char __pyx_k_3_primer_sequence_used_by_cutada[] = "3' primer sequence used by cutadapt (defaults to 'default', which will not run cutadapt)";
static char __pyx_k_5_primer_sequence_used_by_cutada[] = "5' primer sequence used by cutadapt (defaults to 'default', which will run cutadapt to only trim the 3' primer sequence, if given)";
static char __pyx_k_A_comma_joined_list_of_strings_w[] = "A comma-joined list of strings with extra information for informing analysis. Currently in beta support: ffpe, amplicon.";
static char __pyx_k_Additional_aligner_opts_E_g_opts[] = "Additional aligner opts. E.g.: --opts '-L 0' ";
static char __pyx_k_Aligner_program_e_g_bwa_mem_or_b[] = "Aligner program (e.g. bwa mem or bwa aln)";
static char __pyx_k_BAM_file_if_alignment_has_alread[] = "BAM file, if alignment has already run.";
static char __pyx_k_Bed_file_not_used_in_the_alignme[] = "Bed file not used in the alignment but used in the REalignment and MawCluster.SVUtils's GetSVRelevantRecordsPaired";
static char __pyx_k_Calculates_the_quantity_of_input[] = "Calculates the quantity of input DNA needed to reach a given mean PCR redundancy and a given amount of sequencing power.";
static char __pyx_k_Call_SNVs_Assumes_that_reads_hav[] = "Call SNVs. Assumes that reads have been collapsed from a family size of at least 2";
static char __pyx_k_Call_structural_variants_Require[] = "Call structural variants. Requires an Input BAM, coordinate-sorted and indexed, with BMF SV Tags included, and a BED File.";
static char __pyx_k_Config_file_to_hold_this_so_we_d[] = "Config file to hold this so we don't have to specify.";
static char __pyx_k_Coordinate_Sorted_Indexed_Bam_Fi[] = "Coordinate-Sorted, Indexed Bam File";
static char __pyx_k_Distance_around_the_region_of_in[] = "Distance around the region of interest to pad.";
static char __pyx_k_Efficiency_of_ligation_of_adapte[] = "Efficiency of ligation of adapters.";
static char __pyx_k_Flag_to_perform_barcode_rescue_w[] = "Flag to perform barcode rescue with default rescue parameters for experiments with very low library diversity. Currently only supported for paired-end reads.";
static char __pyx_k_Fraction_of_average_read_aligned[] = "Fraction of average read aligned. Default: 0.9";
static char __pyx_k_Fraction_of_reads_not_usable_due[] = "Fraction of reads not usable due to failing QC. Default: 0.1.";
static char __pyx_k_Fraction_of_reads_properly_mappe[] = "Fraction of reads properly mapped with MQ != minMQ for variant-calling.";
static char __pyx_k_Fraction_of_reads_which_are_on_t[] = "Fraction of reads which are on-target. Default: 0.25 (25%).";
static char __pyx_k_Generate_family_size_stats_for_a[] = "Generate family size stats for a flattened fastq file.";
static char __pyx_k_Genome_size_for_organism_Default[] = "Genome size for organism. Defaults to human genome length.";
static char __pyx_k_If_set_check_standard_VCF_for_ca[] = "If set, check standard VCF for calls in the query VCF rather than default behavior, which is checking the query VCF for calls that should be in the standard.";
static char __pyx_k_If_set_writes_both_set_compariso[] = "If set, writes both set comparisons (std vs. query and query vs. standard) for filenames based on the input file name. Stdout not supported.";
static char __pyx_k_Input_VCF_as_created_by_SNVCrawl[] = "Input VCF, as created by SNVCrawler.";
static char __pyx_k_Length_of_inline_barcodes_Ignore[] = "Length of inline barcodes. Ignored for datasets where the molecular barcode is on a secondary index.";
static char __pyx_k_Length_of_interval_to_be_conside[] = "Length of interval to be considered for call.";
static char __pyx_k_Length_of_unique_sequence_groups[] = "Length of unique sequence groups (kmers) to search for in the reference.";
static char __pyx_k_Marks_combines_and_processes_a_d[] = "Marks, combines, and processes a dataset of fastqs for further analysis.";
static char __pyx_k_Maximum_P_value_to_consider_in_e[] = "Maximum P value to consider, in e notation.";
static char __pyx_k_Minimum_Base_Quality_to_consider[] = "Minimum Base Quality to consider";
static char __pyx_k_Minimum_Mapping_Quality_to_consi[] = "Minimum Mapping Quality to consider";
static char __pyx_k_Minimum_base_quality_for_inclusi[] = "Minimum base quality for inclusion. Default: 0.";
static char __pyx_k_Minimum_base_quality_for_variant[] = "Minimum base quality for variant call inclusion. Can be indicated by the config file.";
static char __pyx_k_Minimum_coverage_for_including_a[] = "Minimum coverage for including a position in the BamToCoverageBed";
static char __pyx_k_Minimum_depth_for_a_cluster_to_b[] = "Minimum depth for a cluster to be considered for call.";
static char __pyx_k_Minimum_family_members_agreed_on[] = "Minimum family members agreed on base for inclusion in variant call";
static char __pyx_k_Minimum_family_size_for_true_fam[] = "Minimum family size for true families.";
static char __pyx_k_Minimum_fraction_of_reads_in_fam[] = "Minimum fraction of reads in family to agree on a base call for inclusion in variant calling.";
static char __pyx_k_Minimum_mapping_quality_for_incl[] = "Minimum mapping quality for inclusion. Default: 0.";
static char __pyx_k_Minimum_mapping_quality_for_vari[] = "Minimum mapping quality for variant call inclusion. Can be indicated by the config file.";
static char __pyx_k_Number_of_bases_from_each_read_w[] = "Number of bases from each read with which to salt the barcode.";
static char __pyx_k_Number_of_bases_from_the_start_o[] = "Number of bases from the start of reads 1 and 2 to add to the barcode.";
static char __pyx_k_Number_of_bases_in_each_directio[] = "Number of bases in each direction to pad the bed intervals for reads bleeding out into surrounding regions.";
static char __pyx_k_Number_of_template_molecules_seq[] = "Number of template molecules sequenced. (Both reads in a pair count as 1 total)";
static char __pyx_k_Parallelize_variant_calling_acti[] = "Parallelize variant calling activated by this flag.";
static char __pyx_k_Path_to_a_config_file_If_set_loa[] = "Path to a config file. If set, load arguments from this file, overriding the defaults founds in _bmftools_helper. Any command-line arguments override this config file as well.";
static char __pyx_k_Path_to_abra_jar_Can_be_indicate[] = "Path to abra jar. Can be indicated by the config file.";
static char __pyx_k_Path_to_bed_over_which_to_calcul[] = "Path to bed over which to calculate coverage.";
static char __pyx_k_Path_to_config_file_with_setting[] = "Path to config file with settings.";
static char __pyx_k_Path_to_intel_deflator_Speeds_up[] = "Path to intel deflator. Speeds up abra calls.";
static char __pyx_k_Path_to_output_file_Default_stdo[] = "Path to output file. Default: stdout";
static char __pyx_k_Path_to_output_file_If_not_set_d[] = "Path to output file. If not set, defaults to variation on input bam.";
static char __pyx_k_Path_to_reference_file_Must_be_f[] = "Path to reference file. (Must be faidx'd)";
static char __pyx_k_Path_to_reference_index_Can_be_i[] = "Path to reference index. Can be indicated by the config file.";
static char __pyx_k_Path_to_the_abra_realigner_progr[] = "Path to the abra realigner program";
static char __pyx_k_Performs_alignment_and_sam_taggi[] = "Performs alignment and sam tagging of consolidated fastq files to generate a tagged bam.";
static char __pyx_k_Prefix_for_review_directory_wher[] = "Prefix for review directory, where important results files will be moved at the end of analysis.";
static char __pyx_k_Provide_your_aligner_Default_bwa[] = "Provide your aligner. Default: bwa";
static char __pyx_k_Query_VCF_to_compare_to_referenc[] = "Query VCF to compare to reference VCF.";
static char __pyx_k_Read_length_for_abra_KmerSizeEva[] = "Read length (for abra.KmerSizeEvaluator program";
static char __pyx_k_Realigner_program_e_g_abra_or_ga[] = "Realigner program (e.g. abra or gatk)";
static char __pyx_k_Reference_VCF_for_comparing_to_q[] = "Reference VCF for comparing to query VCF.";
static char __pyx_k_Select_which_indel_realigner_you[] = "Select which indel realigner you wish to use. Supported: abra, GATK. Set to None to avoid realignment.";
static char __pyx_k_Set_this_flag_if_the_data_is_pai[] = "Set this flag if the data is paired-end.";
static char __pyx_k_Set_to_true_to_add_the_rescue_st[] = "Set to 'true' to add the rescue step to the family merging.";
static char __pyx_k_Size_of_capture_region_in_number[] = "Size of capture region in number of bases.";
static char __pyx_k_To_change_default_logfile_locati[] = "To change default logfile location.";
static char __pyx_k_Tool_for_selecting_kmers_which_a[] = "Tool for selecting kmers which are unique identifiers for a region of interest for assembly and produces abed file covering these regions.";
static char __pyx_k_Tool_for_splitting_a_VCF_File_wi[] = "Tool for splitting a VCF File with multiple alts per line into a VCF where each line has a unique alt.";
static char __pyx_k_Use_flag_if_using_inline_barcode[] = "Use flag if using inline barcodes method.";
static char __pyx_k_Whether_or_not_SNVCrawler_is_sla[] = "Whether or not SNVCrawler is slave instance.";
static char __pyx_k_Whether_or_not_to_count_copies_o[] = "Whether or not to count copies of the genome by strand rather than by dsDNA.";
static char __pyx_k_Whether_the_experiment_is_single[] = "Whether the experiment is single-end or not. Default: False";
static char __pyx_k_full_path_to_bed_file_used_for_v[] = "full path to bed file used for variant-calling steps.Can be indicated by the config file.";
static PyObject *__pyx_kp_s_3_primer_sequence_for_cutadapt;
static PyObject *__pyx_kp_s_3_primer_sequence_used_by_cutada;
static PyObject *__pyx_kp_s_5_primer_sequence_for_cutadapt;
static PyObject *__pyx_kp_s_5_primer_sequence_used_by_cutada;
static PyObject *__pyx_kp_s_A_comma_joined_list_of_strings_w;
static PyObject *__pyx_kp_s_Additional_aligner_opts_E_g_opts;
static PyObject *__pyx_kp_s_Aligner_program_e_g_bwa_mem_or_b;
static PyObject *__pyx_n_s_ArgumentParser;
static PyObject *__pyx_n_s_ArgumentSketcher;
static PyObject *__pyx_kp_s_BAM;
static PyObject *__pyx_kp_s_BAM_file_if_alignment_has_alread;
static PyObject *__pyx_n_s_BEDFile;
static PyObject *__pyx_n_s_BedCovParser;
static PyObject *__pyx_kp_s_Bed_file_not_used_in_the_alignme;
static PyObject *__pyx_kp_s_Calculates_the_quantity_of_input;
static PyObject *__pyx_kp_s_Call_SNVs_Assumes_that_reads_hav;
static PyObject *__pyx_kp_s_Call_structural_variants_Require;
static PyObject *__pyx_kp_s_Calls_FastDepthOfCoverage;
static PyObject *__pyx_n_s_Chapman;
static PyObject *__pyx_kp_s_Compares_VCF_files;
static PyObject *__pyx_kp_s_Config_file_to_hold_this_so_we_d;
static PyObject *__pyx_kp_s_Coordinate_Sorted_Indexed_Bam_Fi;
static PyObject *__pyx_n_s_DMultiPlexParser;
static PyObject *__pyx_kp_s_Desired_mean_family_size;
static PyObject *__pyx_kp_s_Distance_around_the_region_of_in;
static PyObject *__pyx_kp_s_Efficiency_of_ligation_of_adapte;
static PyObject *__pyx_kp_s_FM;
static PyObject *__pyx_n_s_FamStatsParser;
static PyObject *__pyx_kp_s_FastDOCPath;
static PyObject *__pyx_n_s_FileType;
static PyObject *__pyx_kp_s_Flag_to_perform_barcode_rescue_w;
static PyObject *__pyx_kp_s_Fraction_of_average_read_aligned;
static PyObject *__pyx_kp_s_Fraction_of_reads_not_usable_due;
static PyObject *__pyx_kp_s_Fraction_of_reads_properly_mappe;
static PyObject *__pyx_kp_s_Fraction_of_reads_which_are_on_t;
static PyObject *__pyx_kp_s_Full_path_to_bed_file;
static PyObject *__pyx_kp_s_Generate_family_size_stats_for_a;
static PyObject *__pyx_kp_s_Genome_size_for_organism_Default;
static PyObject *__pyx_n_s_GetUniqueKmerBedParser;
static PyObject *__pyx_kp_s_Gets_counts_and_frequencies_for;
static PyObject *__pyx_n_s_HomingSequence;
static PyObject *__pyx_kp_s_Homing_sequence_for_samples;
static PyObject *__pyx_kp_s_If_set_check_standard_VCF_for_ca;
static PyObject *__pyx_kp_s_If_set_writes_both_set_compariso;
static PyObject *__pyx_n_s_InFastqs;
static PyObject *__pyx_kp_s_Index_Fastq;
static PyObject *__pyx_n_s_InputQtyParser;
static PyObject *__pyx_kp_s_Input_BAM_Coordinate_sorted_and;
static PyObject *__pyx_kp_s_Input_Fastq_Files;
static PyObject *__pyx_kp_s_Input_VCF;
static PyObject *__pyx_kp_s_Input_VCF_as_created_by_SNVCrawl;
static PyObject *__pyx_kp_s_Length_of_each_read;
static PyObject *__pyx_kp_s_Length_of_inline_barcodes_Ignore;
static PyObject *__pyx_kp_s_Length_of_interval_to_be_conside;
static PyObject *__pyx_kp_s_Length_of_unique_sequence_groups;
static PyObject *__pyx_n_s_Logger;
static PyObject *__pyx_n_s_MainSubparser;
static PyObject *__pyx_kp_s_Marks_combines_and_processes_a_d;
static PyObject *__pyx_n_s_MawCluster_BCBam;
static PyObject *__pyx_kp_s_MaxPValue;
static PyObject *__pyx_kp_s_Maximum_P_value_to_consider_in_e;
static PyObject *__pyx_kp_s_Maximum_difference_between_edit;
static PyObject *__pyx_kp_s_Memory_to_use_for_sorting_fastq;
static PyObject *__pyx_n_s_Metrics;
static PyObject *__pyx_kp_s_Minimum_Base_Quality_to_consider;
static PyObject *__pyx_kp_s_Minimum_Mapping_Quality_to_consi;
static PyObject *__pyx_kp_s_Minimum_base_quality_for_inclusi;
static PyObject *__pyx_kp_s_Minimum_base_quality_for_variant;
static PyObject *__pyx_kp_s_Minimum_coverage_for_including_a;
static PyObject *__pyx_kp_s_Minimum_depth_for_a_cluster_to_b;
static PyObject *__pyx_kp_s_Minimum_family_agreed_on_base;
static PyObject *__pyx_kp_s_Minimum_family_members_agreed_on;
static PyObject *__pyx_kp_s_Minimum_family_size_for_true_fam;
static PyObject *__pyx_kp_s_Minimum_fraction_of_reads_in_fam;
static PyObject *__pyx_kp_s_Minimum_mapping_quality_for_incl;
static PyObject *__pyx_kp_s_Minimum_mapping_quality_for_vari;
static PyObject *__pyx_kp_s_Mismatch_limit;
static PyObject *__pyx_kp_s_Name_for_logfile;
static PyObject *__pyx_kp_s_Number_of_allowed_mismatches;
static PyObject *__pyx_kp_s_Number_of_bases_from_each_read_w;
static PyObject *__pyx_kp_s_Number_of_bases_from_the_start_o;
static PyObject *__pyx_kp_s_Number_of_bases_in_each_directio;
static PyObject *__pyx_kp_s_Number_of_template_molecules_seq;
static PyObject *__pyx_kp_s_Number_of_threads;
static PyObject *__pyx_kp_s_Number_of_threads_to_use;
static PyObject *__pyx_n_s_OutputVCF;
static PyObject *__pyx_kp_s_Output_VCF_File;
static PyObject *__pyx_kp_s_Output_VCF_If_unset_defaults_to;
static PyObject *__pyx_kp_s_Output_tsv;
static PyObject *__pyx_kp_s_Outputs_version_of_BMFTools;
static PyObject *__pyx_n_s_PSNVParser;
static PyObject *__pyx_n_s_Palin;
static PyObject *__pyx_kp_s_Parallel_SNV_calls;
static PyObject *__pyx_kp_s_Parallelize_variant_calling_acti;
static PyObject *__pyx_kp_s_Path_to_FastDOC_executable_jar;
static PyObject *__pyx_kp_s_Path_to_GATK_jar_v1_6;
static PyObject *__pyx_kp_s_Path_to_a_config_file_If_set_loa;
static PyObject *__pyx_kp_s_Path_to_abra_jar_Can_be_indicate;
static PyObject *__pyx_kp_s_Path_to_bed_over_which_to_calcul;
static PyObject *__pyx_kp_s_Path_to_bedfile;
static PyObject *__pyx_kp_s_Path_to_config_file_Can_be_used;
static PyObject *__pyx_kp_s_Path_to_config_file_with_setting;
static PyObject *__pyx_kp_s_Path_to_fastq_files;
static PyObject *__pyx_kp_s_Path_to_flattened_fastq_file;
static PyObject *__pyx_kp_s_Path_to_index_fastq;
static PyObject *__pyx_kp_s_Path_to_input_BAM;
static PyObject *__pyx_kp_s_Path_to_input_bed_file_defining;
static PyObject *__pyx_kp_s_Path_to_intel_deflator_Speeds_up;
static PyObject *__pyx_kp_s_Path_to_output_bed_file;
static PyObject *__pyx_kp_s_Path_to_output_file_Default_stdo;
static PyObject *__pyx_kp_s_Path_to_output_file_If_not_set_d;
static PyObject *__pyx_kp_s_Path_to_picard_jar_Required_for;
static PyObject *__pyx_kp_s_Path_to_reference_file_Must_be_f;
static PyObject *__pyx_kp_s_Path_to_reference_index;
static PyObject *__pyx_kp_s_Path_to_reference_index_Can_be_i;
static PyObject *__pyx_kp_s_Path_to_the_GATK_Jar;
static PyObject *__pyx_kp_s_Path_to_the_abra_realigner_progr;
static PyObject *__pyx_kp_s_Performs_alignment_and_sam_taggi;
static PyObject *__pyx_kp_s_Prefix_for_review_directory_wher;
static PyObject *__pyx_n_s_Primarylogger;
static PyObject *__pyx_kp_s_Provide_reference_fasta;
static PyObject *__pyx_kp_s_Provide_your_aligner_Default_bwa;
static PyObject *__pyx_kp_s_Provide_your_fastq_file_s;
static PyObject *__pyx_kp_s_Query_VCF_to_compare_to_referenc;
static PyObject *__pyx_kp_s_Read_length;
static PyObject *__pyx_kp_s_Read_length_for_abra_KmerSizeEva;
static PyObject *__pyx_kp_s_Realigner_program_e_g_abra_or_ga;
static PyObject *__pyx_kp_s_Reference_FASTA_to_align_fastqs;
static PyObject *__pyx_kp_s_Reference_VCF_for_comparing_to_q;
static PyObject *__pyx_n_s_RescueShadingParser;
static PyObject *__pyx_kp_s_Rescue_fastq_shading;
static PyObject *__pyx_n_s_ReviewDirComponents;
static PyObject *__pyx_n_s_ReviewDirFiles;
static PyObject *__pyx_kp_s_Run_a_full_pipeline_analysis;
static PyObject *__pyx_n_s_SMAParser;
static PyObject *__pyx_n_s_SNVParser;
static PyObject *__pyx_n_s_SVParser;
static PyObject *__pyx_n_s_SampleMetrics;
static PyObject *__pyx_kp_s_Select_which_indel_realigner_you;
static PyObject *__pyx_kp_s_Set_non_default_prefix;
static PyObject *__pyx_kp_s_Set_output_file_path_instead_of;
static PyObject *__pyx_kp_s_Set_this_flag_if_the_data_is_pai;
static PyObject *__pyx_kp_s_Set_to_true_to_add_the_rescue_st;
static PyObject *__pyx_kp_s_Size_of_capture_region_in_number;
static PyObject *__pyx_n_s_TagBamParser;
static PyObject *__pyx_kp_s_Tag_a_BAM_file_with_appropriate;
static PyObject *__pyx_kp_s_Tag_to_append_to_the_output_VCF;
static PyObject *__pyx_kp_s_Tagged_Merged_Fastq_File_s;
static PyObject *__pyx_kp_s_To_change_default_logfile_locati;
static PyObject *__pyx_kp_s_Tool_for_selecting_kmers_which_a;
static PyObject *__pyx_kp_s_Tool_for_splitting_a_VCF_File_wi;
static PyObject *__pyx_n_s_TrimExt;
static PyObject *__pyx_kp_s_Untagged_Bam_name_sorted;
static PyObject *__pyx_kp_s_Use_flag_if_using_inline_barcode;
static PyObject *__pyx_n_s_VCFCmpParser;
static PyObject *__pyx_n_s_VCFStatsParser;
static PyObject *__pyx_kp_s_Whether_or_not_SNVCrawler_is_sla;
static PyObject *__pyx_kp_s_Whether_or_not_to_count_copies_o;
static PyObject *__pyx_kp_s_Whether_the_experiment_is_single;
static PyObject *__pyx_kp_s_Y_b_d_H_m_S;
static PyObject *__pyx_kp_s__117;
static PyObject *__pyx_kp_s__146;
static PyObject *__pyx_kp_s__36;
static PyObject *__pyx_kp_s_a;
static PyObject *__pyx_kp_s_abrapath;
static PyObject *__pyx_n_s_abrapath_2;
static PyObject *__pyx_n_s_action;
static PyObject *__pyx_n_s_add_argument;
static PyObject *__pyx_n_s_add_parser;
static PyObject *__pyx_n_s_add_subparsers;
static PyObject *__pyx_n_s_alignTagBamParser;
static PyObject *__pyx_kp_s_aligner;
static PyObject *__pyx_n_s_aligner_2;
static PyObject *__pyx_n_s_aligntagbam;
static PyObject *__pyx_kp_s_analysisTag;
static PyObject *__pyx_n_s_argparse;
static PyObject *__pyx_n_s_argv;
static PyObject *__pyx_kp_s_b;
static PyObject *__pyx_n_s_bam;
static PyObject *__pyx_n_s_basename;
static PyObject *__pyx_kp_s_basename_s;
static PyObject *__pyx_kp_s_bcLen;
static PyObject *__pyx_kp_s_bed;
static PyObject *__pyx_n_s_bed_2;
static PyObject *__pyx_kp_s_bed_buffer;
static PyObject *__pyx_n_s_bedcov;
static PyObject *__pyx_n_s_bedpath;
static PyObject *__pyx_n_s_bmfsuites;
static PyObject *__pyx_kp_s_c;
static PyObject *__pyx_kp_s_check_both;
static PyObject *__pyx_kp_s_check_std;
static PyObject *__pyx_kp_s_conf;
static PyObject *__pyx_n_s_conf_2;
static PyObject *__pyx_kp_s_d;
static PyObject *__pyx_n_s_dateStr;
static PyObject *__pyx_n_s_datetime;
static PyObject *__pyx_n_s_default;
static PyObject *__pyx_n_s_description;
static PyObject *__pyx_n_s_dest;
static PyObject *__pyx_n_s_dmp;
static PyObject *__pyx_kp_s_e;
static PyObject *__pyx_n_s_end;
static PyObject *__pyx_n_s_exit;
static PyObject *__pyx_kp_s_experiment;
static PyObject *__pyx_kp_s_f;
static PyObject *__pyx_n_s_famstats;
static PyObject *__pyx_kp_s_fastq;
static PyObject *__pyx_kp_s_fastqs;
static PyObject *__pyx_n_s_file;
static PyObject *__pyx_kp_s_file_prefix;
static PyObject *__pyx_n_s_fq;
static PyObject *__pyx_kp_s_full_path_to_bed_file_used_for_v;
static PyObject *__pyx_kp_s_g;
static PyObject *__pyx_n_s_gatk;
static PyObject *__pyx_kp_s_gatkpath;
static PyObject *__pyx_kp_s_genome_size;
static PyObject *__pyx_n_s_getLogger;
static PyObject *__pyx_n_s_getuniquekmersbed;
static PyObject *__pyx_kp_s_head;
static PyObject *__pyx_n_s_help;
static PyObject *__pyx_kp_s_homing;
static PyObject *__pyx_kp_s_i;
static PyObject *__pyx_n_s_i_2;
static PyObject *__pyx_kp_s_idxFastq;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_inBAM;
static PyObject *__pyx_n_s_inFq;
static PyObject *__pyx_n_s_inFqs;
static PyObject *__pyx_n_s_inVCF;
static PyObject *__pyx_kp_s_inbed;
static PyObject *__pyx_n_s_inbed_2;
static PyObject *__pyx_kp_s_indelRealigner;
static PyObject *__pyx_n_s_indexFastq;
static PyObject *__pyx_kp_s_indexFq;
static PyObject *__pyx_kp_s_inline_barcodes;
static PyObject *__pyx_kp_s_insert_distance;
static PyObject *__pyx_kp_s_intelDeflator;
static PyObject *__pyx_kp_s_is_slave;
static PyObject *__pyx_kp_s_k;
static PyObject *__pyx_kp_s_keepConsensus;
static PyObject *__pyx_kp_s_kmer;
static PyObject *__pyx_n_s_kmer_2;
static PyObject *__pyx_kp_s_l;
static PyObject *__pyx_kp_s_ligation_efficiency;
static PyObject *__pyx_kp_s_logfile;
static PyObject *__pyx_n_s_logging;
static PyObject *__pyx_kp_s_m;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_main_2;
static PyObject *__pyx_kp_s_mapped_fraction;
static PyObject *__pyx_kp_s_mean_aligned_fraction;
static PyObject *__pyx_n_s_metavar;
static PyObject *__pyx_kp_s_minBQ;
static PyObject *__pyx_kp_s_minClustDepth;
static PyObject *__pyx_kp_s_minCov;
static PyObject *__pyx_kp_s_minFA;
static PyObject *__pyx_kp_s_minFam;
static PyObject *__pyx_kp_s_minFracAgreed;
static PyObject *__pyx_kp_s_minMQ;
static PyObject *__pyx_kp_s_minPileupLen;
static PyObject *__pyx_kp_s_mismatches;
static PyObject *__pyx_n_s_mismatches_2;
static PyObject *__pyx_kp_s_mm;
static PyObject *__pyx_kp_s_n;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_nargs;
static PyObject *__pyx_kp_s_no_strand_correction;
static PyObject *__pyx_n_s_now;
static PyObject *__pyx_kp_s_number_of_templates;
static PyObject *__pyx_kp_s_o;
static PyObject *__pyx_kp_s_on_target;
static PyObject *__pyx_kp_s_opts;
static PyObject *__pyx_n_s_os;
static PyObject *__pyx_n_s_ospath;
static PyObject *__pyx_kp_s_outTsv;
static PyObject *__pyx_kp_s_outVCF;
static PyObject *__pyx_kp_s_outbed;
static PyObject *__pyx_n_s_outbed_2;
static PyObject *__pyx_kp_s_outfile;
static PyObject *__pyx_kp_s_outfile_handle;
static PyObject *__pyx_kp_s_p;
static PyObject *__pyx_kp_s_p3Seq;
static PyObject *__pyx_kp_s_p5Seq;
static PyObject *__pyx_kp_s_padding;
static PyObject *__pyx_kp_s_paired;
static PyObject *__pyx_n_s_pairedBarcodeTagging;
static PyObject *__pyx_kp_s_parallel;
static PyObject *__pyx_n_s_parse_args;
static PyObject *__pyx_n_s_parser;
static PyObject *__pyx_n_s_path;
static PyObject *__pyx_kp_s_picardpath;
static PyObject *__pyx_n_s_pl;
static PyObject *__pyx_n_s_primer3Seq;
static PyObject *__pyx_n_s_primer5Seq;
static PyObject *__pyx_n_s_print;
static PyObject *__pyx_n_s_printlog;
static PyObject *__pyx_n_s_psnv;
static PyObject *__pyx_kp_s_qc_fail;
static PyObject *__pyx_n_s_qty;
static PyObject *__pyx_n_s_queryVCF;
static PyObject *__pyx_kp_s_r;
static PyObject *__pyx_kp_s_readLength;
static PyObject *__pyx_kp_s_read_length;
static PyObject *__pyx_kp_s_readlength;
static PyObject *__pyx_n_s_readlength_2;
static PyObject *__pyx_n_s_reads;
static PyObject *__pyx_kp_s_realigner;
static PyObject *__pyx_n_s_realigner_2;
static PyObject *__pyx_kp_s_ref;
static PyObject *__pyx_n_s_ref_2;
static PyObject *__pyx_kp_s_region_size;
static PyObject *__pyx_n_s_required;
static PyObject *__pyx_kp_s_rescue;
static PyObject *__pyx_kp_s_review_dir;
static PyObject *__pyx_n_s_rsq;
static PyObject *__pyx_kp_s_s;
static PyObject *__pyx_n_s_singleBarcodeTagging;
static PyObject *__pyx_kp_s_single_end;
static PyObject *__pyx_n_s_sma;
static PyObject *__pyx_n_s_snv;
static PyObject *__pyx_kp_s_sortMem;
static PyObject *__pyx_kp_s_std;
static PyObject *__pyx_n_s_store_true;
static PyObject *__pyx_n_s_strftime;
static PyObject *__pyx_n_s_subparsers;
static PyObject *__pyx_n_s_sv;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_kp_s_t;
static PyObject *__pyx_n_s_tagbam;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_kp_s_threads;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_n_s_utilBMF_ArgumentSketcher;
static PyObject *__pyx_n_s_utilBMF_GlobalReporting;
static PyObject *__pyx_n_s_utilBMF_HTSUtils;
static PyObject *__pyx_n_s_utilBMF_bmftools;
static PyObject *__pyx_n_s_v;
static PyObject *__pyx_n_s_vcfcmp;
static PyObject *__pyx_n_s_vcfstats;
static PyObject *__pyx_n_s_versionParser;
static PyObject *__pyx_n_s_w;
static PyObject *__pyx_kp_s_yggdrasil_workspace_BMFTools_ut;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_2;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__15;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__29;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__31;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__33;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__37;
static PyObject *__pyx_tuple__38;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__40;
static PyObject *__pyx_tuple__41;
static PyObject *__pyx_tuple__42;
static PyObject *__pyx_tuple__43;
static PyObject *__pyx_tuple__44;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__46;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__48;
static PyObject *__pyx_tuple__49;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__54;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__56;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__58;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__60;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__62;
static PyObject *__pyx_tuple__63;
static PyObject *__pyx_tuple__64;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__68;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__71;
static PyObject *__pyx_tuple__72;
static PyObject *__pyx_tuple__73;
static PyObject *__pyx_tuple__74;
static PyObject *__pyx_tuple__75;
static PyObject *__pyx_tuple__76;
static PyObject *__pyx_tuple__77;
static PyObject *__pyx_tuple__78;
static PyObject *__pyx_tuple__79;
static PyObject *__pyx_tuple__80;
static PyObject *__pyx_tuple__81;
static PyObject *__pyx_tuple__82;
static PyObject *__pyx_tuple__83;
static PyObject *__pyx_tuple__84;
static PyObject *__pyx_tuple__85;
static PyObject *__pyx_tuple__86;
static PyObject *__pyx_tuple__87;
static PyObject *__pyx_tuple__88;
static PyObject *__pyx_tuple__89;
static PyObject *__pyx_tuple__90;
static PyObject *__pyx_tuple__91;
static PyObject *__pyx_tuple__92;
static PyObject *__pyx_tuple__93;
static PyObject *__pyx_tuple__94;
static PyObject *__pyx_tuple__95;
static PyObject *__pyx_tuple__96;
static PyObject *__pyx_tuple__97;
static PyObject *__pyx_tuple__98;
static PyObject *__pyx_tuple__99;
static PyObject *__pyx_slice__145;
static PyObject *__pyx_tuple__100;
static PyObject *__pyx_tuple__101;
static PyObject *__pyx_tuple__102;
static PyObject *__pyx_tuple__103;
static PyObject *__pyx_tuple__104;
static PyObject *__pyx_tuple__105;
static PyObject *__pyx_tuple__106;
static PyObject *__pyx_tuple__107;
static PyObject *__pyx_tuple__108;
static PyObject *__pyx_tuple__109;
static PyObject *__pyx_tuple__110;
static PyObject *__pyx_tuple__111;
static PyObject *__pyx_tuple__112;
static PyObject *__pyx_tuple__113;
static PyObject *__pyx_tuple__114;
static PyObject *__pyx_tuple__115;
static PyObject *__pyx_tuple__116;
static PyObject *__pyx_tuple__118;
static PyObject *__pyx_tuple__119;
static PyObject *__pyx_tuple__120;
static PyObject *__pyx_tuple__121;
static PyObject *__pyx_tuple__122;
static PyObject *__pyx_tuple__123;
static PyObject *__pyx_tuple__124;
static PyObject *__pyx_tuple__125;
static PyObject *__pyx_tuple__126;
static PyObject *__pyx_tuple__127;
static PyObject *__pyx_tuple__128;
static PyObject *__pyx_tuple__129;
static PyObject *__pyx_tuple__130;
static PyObject *__pyx_tuple__131;
static PyObject *__pyx_tuple__132;
static PyObject *__pyx_tuple__133;
static PyObject *__pyx_tuple__134;
static PyObject *__pyx_tuple__135;
static PyObject *__pyx_tuple__136;
static PyObject *__pyx_tuple__137;
static PyObject *__pyx_tuple__138;
static PyObject *__pyx_tuple__139;
static PyObject *__pyx_tuple__140;
static PyObject *__pyx_tuple__141;
static PyObject *__pyx_tuple__142;
static PyObject *__pyx_tuple__143;
static PyObject *__pyx_tuple__144;
static PyObject *__pyx_tuple__147;
static PyObject *__pyx_codeobj__148;

/* "utilBMF/bmftools":22
 * 
 * 
 * def main():             # <<<<<<<<<<<<<<
 *     import argparse
 *     parser = argparse.ArgumentParser()
 */

/* Python wrapper */
static PyObject *__pyx_pw_7utilBMF_8bmftools_1main(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyMethodDef __pyx_mdef_7utilBMF_8bmftools_1main = {"main", (PyCFunction)__pyx_pw_7utilBMF_8bmftools_1main, METH_NOARGS, 0};
static PyObject *__pyx_pw_7utilBMF_8bmftools_1main(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("main (wrapper)", 0);
  __pyx_r = __pyx_pf_7utilBMF_8bmftools_main(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7utilBMF_8bmftools_main(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_v_argparse = NULL;
  PyObject *__pyx_v_parser = NULL;
  PyObject *__pyx_v_subparsers = NULL;
  PyObject *__pyx_v_MainSubparser = NULL;
  PyObject *__pyx_v_BedCovParser = NULL;
  PyObject *__pyx_v_alignTagBamParser = NULL;
  PyObject *__pyx_v_TagBamParser = NULL;
  PyObject *__pyx_v_RescueShadingParser = NULL;
  CYTHON_UNUSED PyObject *__pyx_v_versionParser = NULL;
  PyObject *__pyx_v_InputQtyParser = NULL;
  PyObject *__pyx_v_PSNVParser = NULL;
  PyObject *__pyx_v_VCFCmpParser = NULL;
  PyObject *__pyx_v_VCFStatsParser = NULL;
  PyObject *__pyx_v_DMultiPlexParser = NULL;
  PyObject *__pyx_v_SNVParser = NULL;
  PyObject *__pyx_v_SVParser = NULL;
  PyObject *__pyx_v_SMAParser = NULL;
  PyObject *__pyx_v_GetUniqueKmerBedParser = NULL;
  PyObject *__pyx_v_FamStatsParser = NULL;
  PyObject *__pyx_v_Palin = NULL;
  CYTHON_UNUSED PyObject *__pyx_v_dateStr = NULL;
  PyObject *__pyx_v_basename = NULL;
  PyObject *__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *(*__pyx_t_9)(PyObject *);
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("main", 0);

  /* "utilBMF/bmftools":23
 * 
 * def main():
 *     import argparse             # <<<<<<<<<<<<<<
 *     parser = argparse.ArgumentParser()
 *     subparsers = parser.add_subparsers(dest="bmfsuites")
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_argparse, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_argparse = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":24
 * def main():
 *     import argparse
 *     parser = argparse.ArgumentParser()             # <<<<<<<<<<<<<<
 *     subparsers = parser.add_subparsers(dest="bmfsuites")
 *     MainSubparser = subparsers.add_parser(
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_argparse, __pyx_n_s_ArgumentParser); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_parser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":25
 *     import argparse
 *     parser = argparse.ArgumentParser()
 *     subparsers = parser.add_subparsers(dest="bmfsuites")             # <<<<<<<<<<<<<<
 *     MainSubparser = subparsers.add_parser(
 *         "main", description="Run a full pipeline analysis.")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser, __pyx_n_s_add_subparsers); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dest, __pyx_n_s_bmfsuites) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_subparsers = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":26
 *     parser = argparse.ArgumentParser()
 *     subparsers = parser.add_subparsers(dest="bmfsuites")
 *     MainSubparser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "main", description="Run a full pipeline analysis.")
 *     BedCovParser = subparsers.add_parser(
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Run_a_full_pipeline_analysis) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_MainSubparser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":28
 *     MainSubparser = subparsers.add_parser(
 *         "main", description="Run a full pipeline analysis.")
 *     BedCovParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "bedcov", description="Calls FastDepthOfCoverage.")
 *     alignTagBamParser = subparsers.add_parser(
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Calls_FastDepthOfCoverage) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__2, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_BedCovParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":30
 *     BedCovParser = subparsers.add_parser(
 *         "bedcov", description="Calls FastDepthOfCoverage.")
 *     alignTagBamParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "aligntagbam", description=("Performs alignment and sam tagging of"
 *                                     " consolidated fastq files to generate "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 30; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 30; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Performs_alignment_and_sam_taggi) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 30; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__3, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 30; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_alignTagBamParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":34
 *                                     " consolidated fastq files to generate "
 *                                     "a tagged bam."))
 *     TagBamParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "tagbam", description=("Tag a BAM file with appropriate information"
 *                                " from merged fastq files."))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Tag_a_BAM_file_with_appropriate) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__4, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_TagBamParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":37
 *         "tagbam", description=("Tag a BAM file with appropriate information"
 *                                " from merged fastq files."))
 *     RescueShadingParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "rsq", description="Rescue fastq shading.")
 *     versionParser = subparsers.add_parser(
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Rescue_fastq_shading) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__5, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_RescueShadingParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":39
 *     RescueShadingParser = subparsers.add_parser(
 *         "rsq", description="Rescue fastq shading.")
 *     versionParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "v", description="Outputs version of BMFTools.")
 *     InputQtyParser = subparsers.add_parser(
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Outputs_version_of_BMFTools) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__6, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_versionParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":41
 *     versionParser = subparsers.add_parser(
 *         "v", description="Outputs version of BMFTools.")
 *     InputQtyParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "qty",
 *         description=("Calculates the quantity of input DNA needed to reach "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Calculates_the_quantity_of_input) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__7, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_InputQtyParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":46
 *                      "a given mean PCR redundancy and a given amount of "
 *                      "sequencing power."))
 *     PSNVParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "psnv", description="Parallel SNV calls.")
 *     PSNVParser.add_argument(
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Parallel_SNV_calls) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__8, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_PSNVParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":48
 *     PSNVParser = subparsers.add_parser(
 *         "psnv", description="Parallel SNV calls.")
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_PSNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Config_file_to_hold_this_so_we_d) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":51
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)             # <<<<<<<<<<<<<<
 *     PSNVParser.add_argument(
 *         "--threads",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":48
 *     PSNVParser = subparsers.add_parser(
 *         "psnv", description="Parallel SNV calls.")
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__9, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":52
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--threads",
 *         help="Number of threads.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_PSNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_threads) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":55
 *         "--threads",
 *         help="Number of threads.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     PSNVParser.add_argument(
 *         "-o",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":52
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--threads",
 *         help="Number of threads.",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__10, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":56
 *         help="Number of threads.",
 *         type=int)
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outVCF",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_PSNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Output_VCF_File) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":60
 *         "--outVCF",
 *         help="Output VCF File.",
 *         default=None,             # <<<<<<<<<<<<<<
 *         metavar="OutputVCF")
 *     PSNVParser.add_argument("inBAM",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_OutputVCF) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":56
 *         help="Number of threads.",
 *         type=int)
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outVCF",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__11, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":62
 *         default=None,
 *         metavar="OutputVCF")
 *     PSNVParser.add_argument("inBAM",             # <<<<<<<<<<<<<<
 *                             help="Input BAM, Coordinate-sorted and indexed, "
 *                             "with BMF Tags included. bmftools runs on unflat"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_PSNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Input_BAM_Coordinate_sorted_and) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":67
 *                             "tened BAMs, but the results are not reliable be"
 *                             "cause this program assumes as much.",
 *                             type=str)             # <<<<<<<<<<<<<<
 *     VCFCmpParser = subparsers.add_parser(
 *         "vcfcmp", description="Compares VCF files.")
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":62
 *         default=None,
 *         metavar="OutputVCF")
 *     PSNVParser.add_argument("inBAM",             # <<<<<<<<<<<<<<
 *                             help="Input BAM, Coordinate-sorted and indexed, "
 *                             "with BMF Tags included. bmftools runs on unflat"
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__12, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":68
 *                             "cause this program assumes as much.",
 *                             type=str)
 *     VCFCmpParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "vcfcmp", description="Compares VCF files.")
 *     VCFStatsParser = subparsers.add_parser("vcfstats",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Compares_VCF_files) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__13, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_VCFCmpParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":70
 *     VCFCmpParser = subparsers.add_parser(
 *         "vcfcmp", description="Compares VCF files.")
 *     VCFStatsParser = subparsers.add_parser("vcfstats",             # <<<<<<<<<<<<<<
 *                                            description="Gets counts and"
 *                                            " frequencies for all SNV tr"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Gets_counts_and_frequencies_for) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__14, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_VCFStatsParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":74
 *                                            " frequencies for all SNV tr"
 *                                            "ansitions.")
 *     DMultiPlexParser = subparsers.add_parser("dmp",             # <<<<<<<<<<<<<<
 *                                              description="Marks, combines, and"
 *                                              " processes a dataset of fastqs f"
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Marks_combines_and_processes_a_d) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__15, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_DMultiPlexParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":78
 *                                              " processes a dataset of fastqs f"
 *                                              "or further analysis.")
 *     SNVParser = subparsers.add_parser("snv", description="Call SNVs. Assumes "             # <<<<<<<<<<<<<<
 *                                       "that reads have been collapsed from a "
 *                                       "family size of at least 2")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Call_SNVs_Assumes_that_reads_hav) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__16, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_SNVParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":81
 *                                       "that reads have been collapsed from a "
 *                                       "family size of at least 2")
 *     SVParser = subparsers.add_parser("sv",             # <<<<<<<<<<<<<<
 *                                      description="Call structural variants. R"
 *                                      "equires an Input BAM, coordinate-sorted"
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Call_structural_variants_Require) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__17, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_SVParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":86
 *                                      " and indexed, with BMF SV Tags included"
 *                                      ", and a BED File.")
 *     SMAParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "sma",
 *         description="Tool for splitting a VCF File with multiple alts per"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Tool_for_splitting_a_VCF_File_wi) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__18, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_SMAParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":90
 *         description="Tool for splitting a VCF File with multiple alts per"
 *         " line into a VCF where each line has a unique alt.")
 *     GetUniqueKmerBedParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "getuniquekmersbed",
 *         description=("Tool for selecting kmers which are unique identifiers "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Tool_for_selecting_kmers_which_a) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__19, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_GetUniqueKmerBedParser = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":95
 *                      "for a region of interest for assembly and produces a"
 *                      "bed file covering these regions."))
 *     SNVParser.add_argument("inBAM",             # <<<<<<<<<<<<<<
 *                            help="Input BAM, Coordinate-sorted and indexed, "
 *                            "with BMF Tags included. bmftools runs on unflat"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Input_BAM_Coordinate_sorted_and) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__20, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":100
 *                            "tened BAMs, but the results are not reliable be"
 *                            "cause this program assumes as much.")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed",
 *         "-b",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Full_path_to_bed_file) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":104
 *         "-b",
 *         help="Full path to bed file.",
 *         default=None,             # <<<<<<<<<<<<<<
 *         metavar="bedpath")
 *     SNVParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_bedpath) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":100
 *                            "tened BAMs, but the results are not reliable be"
 *                            "cause this program assumes as much.")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed",
 *         "-b",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__21, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":106
 *         default=None,
 *         metavar="bedpath")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outVCF",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Output_VCF_File) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":110
 *         "--outVCF",
 *         help="Output VCF File.",
 *         default=None,             # <<<<<<<<<<<<<<
 *         metavar="OutputVCF")
 *     SNVParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_OutputVCF) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":106
 *         default=None,
 *         metavar="bedpath")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outVCF",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__22, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":112
 *         default=None,
 *         metavar="OutputVCF")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minBQ",
 *         help="Minimum Base Quality to consider",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_Base_Quality_to_consider) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":115
 *         "--minBQ",
 *         help="Minimum Base Quality to consider",
 *         default=None,             # <<<<<<<<<<<<<<
 *         type=int)
 *     SNVParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":116
 *         help="Minimum Base Quality to consider",
 *         default=None,
 *         type=int)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "--minMQ",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":112
 *         default=None,
 *         metavar="OutputVCF")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minBQ",
 *         help="Minimum Base Quality to consider",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__23, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":117
 *         default=None,
 *         type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minMQ",
 *         help="Minimum Mapping Quality to consider",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_Mapping_Quality_to_consi) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":120
 *         "--minMQ",
 *         help="Minimum Mapping Quality to consider",
 *         default=None,             # <<<<<<<<<<<<<<
 *         type=int)
 *     SNVParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":121
 *         help="Minimum Mapping Quality to consider",
 *         default=None,
 *         type=int)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "--MaxPValue",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":117
 *         default=None,
 *         type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minMQ",
 *         help="Minimum Mapping Quality to consider",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__24, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":122
 *         default=None,
 *         type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--MaxPValue",
 *         "-p",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Maximum_P_value_to_consider_in_e) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":126
 *         "-p",
 *         help="Maximum P value to consider, in e notation.",
 *         type=float,             # <<<<<<<<<<<<<<
 *         default=None)
 *     SNVParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":127
 *         help="Maximum P value to consider, in e notation.",
 *         type=float,
 *         default=None)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "--keepConsensus",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":122
 *         default=None,
 *         type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--MaxPValue",
 *         "-p",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__25, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":128
 *         type=float,
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--keepConsensus",
 *         "-k",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "utilBMF/bmftools":131
 *         "--keepConsensus",
 *         "-k",
 *         default=None)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "--logfile",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":128
 *         type=float,
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--keepConsensus",
 *         "-k",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__26, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":132
 *         "-k",
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--logfile",
 *         help="Name for logfile.",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Name_for_logfile) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":135
 *         "--logfile",
 *         help="Name for logfile.",
 *         default=None)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "-r",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":132
 *         "-k",
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--logfile",
 *         help="Name for logfile.",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__27, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":136
 *         help="Name for logfile.",
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r",
 *         "--ref",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Provide_reference_fasta) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":140
 *         "--ref",
 *         help="Provide reference fasta.",
 *         default=None)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",
 *                            default=None, type=int)
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":136
 *         help="Name for logfile.",
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r",
 *         "--ref",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__28, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":141
 *         help="Provide reference fasta.",
 *         default=None)
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",             # <<<<<<<<<<<<<<
 *                            default=None, type=int)
 *     SNVParser.add_argument(
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_family_agreed_on_base) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":142
 *         default=None)
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",
 *                            default=None, type=int)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "--conf",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_default, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":141
 *         help="Provide reference fasta.",
 *         default=None)
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",             # <<<<<<<<<<<<<<
 *                            default=None, type=int)
 *     SNVParser.add_argument(
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__29, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":143
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",
 *                            default=None, type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Config_file_to_hold_this_so_we_d) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":146
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)             # <<<<<<<<<<<<<<
 *     SNVParser.add_argument(
 *         "--analysisTag", type=str,
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":143
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",
 *                            default=None, type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__30, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":147
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--analysisTag", type=str,
 *         help=("Tag to append to the output VCF before the file extension."
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "utilBMF/bmftools":148
 *         type=str)
 *     SNVParser.add_argument(
 *         "--analysisTag", type=str,             # <<<<<<<<<<<<<<
 *         help=("Tag to append to the output VCF before the file extension."
 *               "Used to delineate analysis pipelines."))
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Tag_to_append_to_the_output_VCF) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":147
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--analysisTag", type=str,
 *         help=("Tag to append to the output VCF before the file extension."
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__31, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":151
 *         help=("Tag to append to the output VCF before the file extension."
 *               "Used to delineate analysis pipelines."))
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--is-slave",
 *         help="Whether or not SNVCrawler is slave instance.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Whether_or_not_SNVCrawler_is_sla) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__32, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":155
 *         help="Whether or not SNVCrawler is slave instance.",
 *         action="store_true")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minFracAgreed",
 *         help=("Minimum fraction of reads in family to agree on a base call "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SNVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_fraction_of_reads_in_fam) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":159
 *         help=("Minimum fraction of reads in family to agree on a base call "
 *               "for inclusion in variant calling."),
 *         type=float)             # <<<<<<<<<<<<<<
 *     VCFStatsParser.add_argument(
 *         "inVCF",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":155
 *         help="Whether or not SNVCrawler is slave instance.",
 *         action="store_true")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minFracAgreed",
 *         help=("Minimum fraction of reads in family to agree on a base call "
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__33, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":160
 *               "for inclusion in variant calling."),
 *         type=float)
 *     VCFStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inVCF",
 *         help="Input VCF, as created by SNVCrawler.")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFStatsParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Input_VCF_as_created_by_SNVCrawl) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__34, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":163
 *         "inVCF",
 *         help="Input VCF, as created by SNVCrawler.")
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFqs",
 *         nargs="+",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_DMultiPlexParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_nargs, __pyx_kp_s__36) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Input_Fastq_Files) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__35, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":167
 *         nargs="+",
 *         help="Input Fastq Files")
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-i",
 *         "--indexFq",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_DMultiPlexParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_indexFastq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Index_Fastq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":172
 *         metavar="indexFastq",
 *         help="Index Fastq",
 *         required=True)             # <<<<<<<<<<<<<<
 *     DMultiPlexParser.add_argument(
 *         "-f",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":167
 *         nargs="+",
 *         help="Input Fastq Files")
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-i",
 *         "--indexFq",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__37, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":173
 *         help="Index Fastq",
 *         required=True)
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-f",
 *         "--p5Seq",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_DMultiPlexParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_primer5Seq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_5_primer_sequence_used_by_cutada) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__38, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":180
 *               "which will run cutadapt to only trim the 3' primer sequence, "
 *               "if given)"))
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-t",
 *         "--p3Seq",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_DMultiPlexParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_primer3Seq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_3_primer_sequence_used_by_cutada) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__39, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":186
 *         help=("3' primer sequence used by cutadapt (defaults to 'default', "
 *               "which will not run cutadapt)"))
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r", "--rescue", action="store_true",
 *         help=("Flag to perform barcode rescue with default rescue parameters "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_DMultiPlexParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Flag_to_perform_barcode_rescue_w) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__40, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":191
 *               "for experiments with very low library diversity. Currently "
 *               "only supported for paired-end reads."))
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_DMultiPlexParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__41, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":196
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFqs",
 *         nargs="+",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_nargs, __pyx_kp_s__36) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Input_Fastq_Files) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__42, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":200
 *         nargs="+",
 *         help="Input Fastq Files")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-b",
 *         "--bed",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_bed_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Bed_file_not_used_in_the_alignme) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__43, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":206
 *         help=("Bed file not used in the alignment but used in the REalignment"
 *               " and MawCluster.SVUtils's GetSVRelevantRecordsPaired"))
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r",
 *         "--ref",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_ref_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Reference_FASTA_to_align_fastqs) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__44, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":211
 *         metavar="ref",
 *         help="Reference FASTA to align fastqs to")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-a",
 *         "--aligner",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_aligner_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Aligner_program_e_g_bwa_mem_or_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__45, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":216
 *         metavar="aligner",
 *         help="Aligner program (e.g. bwa mem or bwa aln)")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-g",
 *         "--realigner",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_realigner_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Realigner_program_e_g_abra_or_ga) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__46, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":221
 *         metavar="realigner",
 *         help="Realigner program (e.g. abra or gatk)")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-p", "--gatkpath",
 *         metavar="gatk",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_gatk) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_the_GATK_Jar) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__47, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":225
 *         metavar="gatk",
 *         help="Path to the GATK Jar")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-t",
 *         "--abrapath",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_abrapath_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_the_abra_realigner_progr) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__48, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":230
 *         metavar="abrapath",
 *         help="Path to the abra realigner program")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-l",
 *         "--readlength",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_readlength_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Read_length_for_abra_KmerSizeEva) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":235
 *         metavar="readlength",
 *         help="Read length (for abra.KmerSizeEvaluator program",
 *         type=int)             # <<<<<<<<<<<<<<
 *     alignTagBamParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":230
 *         metavar="abrapath",
 *         help="Path to the abra realigner program")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-l",
 *         "--readlength",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__49, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":236
 *         help="Read length (for abra.KmerSizeEvaluator program",
 *         type=int)
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_alignTagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__50, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":241
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inBAM",
 *         metavar="inBAM",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_TagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_inBAM) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Untagged_Bam_name_sorted) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__51, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":245
 *         metavar="inBAM",
 *         help="Untagged Bam, name-sorted")
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--fastq",
 *         "-f",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_TagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_InFastqs) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_nargs, __pyx_kp_s__36) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Tagged_Merged_Fastq_File_s) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__52, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":251
 *         nargs="+",
 *         help="Tagged, Merged Fastq File(s)")
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile",
 *         help=("Path to output file. If not set, defaults to variation "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_TagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_output_file_If_not_set_d) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":255
 *         help=("Path to output file. If not set, defaults to variation "
 *               "on input bam."),
 *         type=str)             # <<<<<<<<<<<<<<
 *     TagBamParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":251
 *         nargs="+",
 *         help="Tagged, Merged Fastq File(s)")
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile",
 *         help=("Path to output file. If not set, defaults to variation "
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__53, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":256
 *               "on input bam."),
 *         type=str)
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_TagBamParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__54, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":261
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         'bam',
 *         help=("Coordinate-Sorted, Indexed Bam File"),
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Coordinate_Sorted_Indexed_Bam_Fi) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__55, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":265
 *         help=("Coordinate-Sorted, Indexed Bam File"),
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-b",
 *         "--bed",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_bedfile) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__56, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":270
 *         help="Path to bedfile.",
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minMQ",
 *         "-m",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_mapping_quality_for_incl) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":274
 *         "-m",
 *         help="Minimum mapping quality for inclusion. Default: 0.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     SVParser.add_argument(
 *         "--minBQ",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":270
 *         help="Path to bedfile.",
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minMQ",
 *         "-m",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__57, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":275
 *         help="Minimum mapping quality for inclusion. Default: 0.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minBQ",
 *         help="Minimum base quality for inclusion. Default: 0.",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_base_quality_for_inclusi) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":278
 *         "--minBQ",
 *         help="Minimum base quality for inclusion. Default: 0.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     SVParser.add_argument(
 *         "-o",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":275
 *         help="Minimum mapping quality for inclusion. Default: 0.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minBQ",
 *         help="Minimum base quality for inclusion. Default: 0.",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__58, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":279
 *         help="Minimum base quality for inclusion. Default: 0.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outTsv",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Output_tsv) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__59, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":284
 *         help="Output tsv",
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minPileupLen",
 *         "-l",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Length_of_interval_to_be_conside) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":288
 *         "-l",
 *         help="Length of interval to be considered for call.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     SVParser.add_argument(
 *         "--minClustDepth",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":284
 *         help="Output tsv",
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minPileupLen",
 *         "-l",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__60, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":289
 *         help="Length of interval to be considered for call.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minClustDepth",
 *         "-d",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "utilBMF/bmftools":292
 *         "--minClustDepth",
 *         "-d",
 *         type=int,             # <<<<<<<<<<<<<<
 *         help="Minimum depth for a cluster to be considered for call.")
 *     SVParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_depth_for_a_cluster_to_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":289
 *         help="Length of interval to be considered for call.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minClustDepth",
 *         "-d",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__61, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":294
 *         type=int,
 *         help="Minimum depth for a cluster to be considered for call.")
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref",
 *         "-r",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_reference_index) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":298
 *         "-r",
 *         help="Path to reference index.",
 *         required=True)             # <<<<<<<<<<<<<<
 *     SVParser.add_argument("--insert-distance",
 *                           "-i",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":294
 *         type=int,
 *         help="Minimum depth for a cluster to be considered for call.")
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref",
 *         "-r",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__62, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":299
 *         help="Path to reference index.",
 *         required=True)
 *     SVParser.add_argument("--insert-distance",             # <<<<<<<<<<<<<<
 *                           "-i",
 *                           help="Maximum difference between edit distances"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Maximum_difference_between_edit) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__63, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":303
 *                           help="Maximum difference between edit distances"
 *                           " for clustering families together")
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SVParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__64, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":308
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inVCF",
 *         help="Input VCF", type=str)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SMAParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Input_VCF) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":310
 *     SMAParser.add_argument(
 *         "inVCF",
 *         help="Input VCF", type=str)             # <<<<<<<<<<<<<<
 *     SMAParser.add_argument(
 *         "--outVCF",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":308
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inVCF",
 *         help="Input VCF", type=str)
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__65, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":311
 *         "inVCF",
 *         help="Input VCF", type=str)
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--outVCF",
 *         "-o",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_SMAParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Output_VCF_If_unset_defaults_to) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__66, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":315
 *         "-o",
 *         help="Output VCF. If unset, defaults to a modified form of the input.")
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmfto"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_SMAParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__67, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":320
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFCmpParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Query_VCF_to_compare_to_referenc) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":322
 *     VCFCmpParser.add_argument(
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)             # <<<<<<<<<<<<<<
 *     VCFCmpParser.add_argument(
 *         "--std", help="Reference VCF for comparing to query VCF.",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":320
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__68, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":323
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--std", help="Reference VCF for comparing to query VCF.",
 *         type=str, required=True)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFCmpParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Reference_VCF_for_comparing_to_q) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":325
 *     VCFCmpParser.add_argument(
 *         "--std", help="Reference VCF for comparing to query VCF.",
 *         type=str, required=True)             # <<<<<<<<<<<<<<
 *     VCFCmpParser.add_argument(
 *         "-o", "--outfile", help="Set output file path instead of stdout.")
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":323
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--std", help="Reference VCF for comparing to query VCF.",
 *         type=str, required=True)
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__69, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":326
 *         "--std", help="Reference VCF for comparing to query VCF.",
 *         type=str, required=True)
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile", help="Set output file path instead of stdout.")
 *     VCFCmpParser.add_argument(
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFCmpParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Set_output_file_path_instead_of) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__70, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":328
 *     VCFCmpParser.add_argument(
 *         "-o", "--outfile", help="Set output file path instead of stdout.")
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--check-std",
 *         help=("If set, check standard VCF for calls in the query VCF rather "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFCmpParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_If_set_check_standard_VCF_for_ca) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__71, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":334
 *               "calls that should be in the standard."),
 *         action="store_true")
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--check-both", action="store_true",
 *         help=("If set, writes both set comparisons (std vs. query and query "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFCmpParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_If_set_writes_both_set_compariso) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__72, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":339
 *               "vs. standard) for filenames based on the input file name. "
 *               "Stdout not supported."))
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmfto"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_VCFCmpParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__73, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":344
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--inbed", "-i",
 *         metavar="inbed",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_inbed_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_input_bed_file_defining) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":349
 *         help=("Path to input bed file defining regions where we are "
 *               "interested in searching for unique kmers."),
 *         type=str)             # <<<<<<<<<<<<<<
 *     GetUniqueKmerBedParser.add_argument(
 *         "--ref", "-r",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":344
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--inbed", "-i",
 *         metavar="inbed",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__74, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":350
 *               "interested in searching for unique kmers."),
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref", "-r",
 *         metavar="ref",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_ref_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_reference_file_Must_be_f) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":354
 *         metavar="ref",
 *         help="Path to reference file. (Must be faidx'd)",
 *         type=str)             # <<<<<<<<<<<<<<
 *     GetUniqueKmerBedParser.add_argument(
 *         "-k", "--kmer", help=("Length of unique sequence groups (kmers) "
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":350
 *               "interested in searching for unique kmers."),
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref", "-r",
 *         metavar="ref",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__75, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":355
 *         help="Path to reference file. (Must be faidx'd)",
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-k", "--kmer", help=("Length of unique sequence groups (kmers) "
 *                               "to search for in the reference."),
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Length_of_unique_sequence_groups) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_kmer_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":359
 *                               "to search for in the reference."),
 *         metavar="kmer",
 *         type=int)             # <<<<<<<<<<<<<<
 *     GetUniqueKmerBedParser.add_argument(
 *         "--padding", "-p",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":355
 *         help="Path to reference file. (Must be faidx'd)",
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-k", "--kmer", help=("Length of unique sequence groups (kmers) "
 *                               "to search for in the reference."),
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__76, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":360
 *         metavar="kmer",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--padding", "-p",
 *         help="Distance around the region of interest to pad.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Distance_around_the_region_of_in) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":363
 *         "--padding", "-p",
 *         help="Distance around the region of interest to pad.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     GetUniqueKmerBedParser.add_argument(
 *         "--mismatches", "-m",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":360
 *         metavar="kmer",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--padding", "-p",
 *         help="Distance around the region of interest to pad.",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__77, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":364
 *         help="Distance around the region of interest to pad.",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mismatches", "-m",
 *         metavar="mismatches",
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_mismatches_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_allowed_mismatches) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":368
 *         metavar="mismatches",
 *         help="Number of allowed mismatches.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     GetUniqueKmerBedParser.add_argument(
 *         "--outbed", "-o",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":364
 *         help="Distance around the region of interest to pad.",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mismatches", "-m",
 *         metavar="mismatches",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__78, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":369
 *         help="Number of allowed mismatches.",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--outbed", "-o",
 *         metavar="outbed",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_outbed_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_output_bed_file) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":373
 *         metavar="outbed",
 *         help="Path to output bed file.",
 *         type=str)             # <<<<<<<<<<<<<<
 *     GetUniqueKmerBedParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":369
 *         help="Number of allowed mismatches.",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--outbed", "-o",
 *         metavar="outbed",
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__79, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "utilBMF/bmftools":374
 *         help="Path to output bed file.",
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmfto"
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_GetUniqueKmerBedParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__80, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":379
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     FamStatsParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "famstats", description=("Generate family size stats for a "
 *                                  "flattened fastq file."))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_subparsers, __pyx_n_s_add_parser); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_description, __pyx_kp_s_Generate_family_size_stats_for_a) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__81, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_FamStatsParser = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "utilBMF/bmftools":382
 *         "famstats", description=("Generate family size stats for a "
 *                                  "flattened fastq file."))
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFq", help="Path to flattened fastq file.", type=str)
 *     FamStatsParser.add_argument(
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_FamStatsParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_flattened_fastq_file) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":383
 *                                  "flattened fastq file."))
 *     FamStatsParser.add_argument(
 *         "inFq", help="Path to flattened fastq file.", type=str)             # <<<<<<<<<<<<<<
 *     FamStatsParser.add_argument(
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":382
 *         "famstats", description=("Generate family size stats for a "
 *                                  "flattened fastq file."))
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFq", help="Path to flattened fastq file.", type=str)
 *     FamStatsParser.add_argument(
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__82, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":384
 *     FamStatsParser.add_argument(
 *         "inFq", help="Path to flattened fastq file.", type=str)
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_FamStatsParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_output_file_Default_stdo) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":386
 *     FamStatsParser.add_argument(
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))             # <<<<<<<<<<<<<<
 *     FamStatsParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_argparse, __pyx_n_s_FileType); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__84, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":384
 *     FamStatsParser.add_argument(
 *         "inFq", help="Path to flattened fastq file.", type=str)
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__83, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":387
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_FamStatsParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__85, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":392
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-n", "--number-of-templates",
 *         help="Number of template molecules sequenced. "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_template_molecules_seq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":396
 *         help="Number of template molecules sequenced. "
 *         "(Both reads in a pair count as 1 total)",
 *         type=int, required=True)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "-p", "--paired",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":392
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-n", "--number-of-templates",
 *         help="Number of template molecules sequenced. "
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__86, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":397
 *         "(Both reads in a pair count as 1 total)",
 *         type=int, required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-p", "--paired",
 *         action="store_true",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Set_this_flag_if_the_data_is_pai) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__87, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":401
 *         action="store_true",
 *         help="Set this flag if the data is paired-end.")
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-l", "--read-length",
 *         help="Length of each read.", type=int,
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Length_of_each_read) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":403
 *     InputQtyParser.add_argument(
 *         "-l", "--read-length",
 *         help="Length of each read.", type=int,             # <<<<<<<<<<<<<<
 *         required=True)
 *     InputQtyParser.add_argument(
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":404
 *         "-l", "--read-length",
 *         help="Length of each read.", type=int,
 *         required=True)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--on-target", "-o",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":401
 *         action="store_true",
 *         help="Set this flag if the data is paired-end.")
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-l", "--read-length",
 *         help="Length of each read.", type=int,
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__88, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":405
 *         help="Length of each read.", type=int,
 *         required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--on-target", "-o",
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Fraction_of_reads_which_are_on_t) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":408
 *         "--on-target", "-o",
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 *         type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--region-size", "-s",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":405
 *         help="Length of each read.", type=int,
 *         required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--on-target", "-o",
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__89, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":409
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--region-size", "-s",
 *         help="Size of capture region in number of bases.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Size_of_capture_region_in_number) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":412
 *         "--region-size", "-s",
 *         help="Size of capture region in number of bases.",
 *         type=int, required=True)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--FM", "-f",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":409
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--region-size", "-s",
 *         help="Size of capture region in number of bases.",
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__90, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":413
 *         help="Size of capture region in number of bases.",
 *         type=int, required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--FM", "-f",
 *         help="Desired mean family size.",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Desired_mean_family_size) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":416
 *         "--FM", "-f",
 *         help="Desired mean family size.",
 *         required=True, type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--genome-size", "-g",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_required, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":413
 *         help="Size of capture region in number of bases.",
 *         type=int, required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--FM", "-f",
 *         help="Desired mean family size.",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__91, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":417
 *         help="Desired mean family size.",
 *         required=True, type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--genome-size", "-g",
 *         help="Genome size for organism. Defaults to human genome length.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Genome_size_for_organism_Default) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":420
 *         "--genome-size", "-g",
 *         help="Genome size for organism. Defaults to human genome length.",
 *         type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--no-strand-correction",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":417
 *         help="Desired mean family size.",
 *         required=True, type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--genome-size", "-g",
 *         help="Genome size for organism. Defaults to human genome length.",
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__92, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":421
 *         help="Genome size for organism. Defaults to human genome length.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--no-strand-correction",
 *         help=("Whether or not to count copies of the genome by "
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Whether_or_not_to_count_copies_o) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__93, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":426
 *               "strand rather than by dsDNA."),
 *         action="store_true")
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--qc-fail",
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Fraction_of_reads_not_usable_due) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":429
 *         "--qc-fail",
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 *         type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--mean-aligned-fraction",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":426
 *               "strand rather than by dsDNA."),
 *         action="store_true")
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--qc-fail",
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__94, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":430
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mean-aligned-fraction",
 *         help=("Fraction of average read aligned. Default: 0.9"),
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Fraction_of_average_read_aligned) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":433
 *         "--mean-aligned-fraction",
 *         help=("Fraction of average read aligned. Default: 0.9"),
 *         type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--mapped-fraction",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":430
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mean-aligned-fraction",
 *         help=("Fraction of average read aligned. Default: 0.9"),
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__95, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":434
 *         help=("Fraction of average read aligned. Default: 0.9"),
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mapped-fraction",
 *         help=("Fraction of reads properly mapped with "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Fraction_of_reads_properly_mappe) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":438
 *         help=("Fraction of reads properly mapped with "
 *               "MQ != minMQ for variant-calling."),
 *         type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--ligation-efficiency",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":434
 *         help=("Fraction of average read aligned. Default: 0.9"),
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mapped-fraction",
 *         help=("Fraction of reads properly mapped with "
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__96, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":439
 *               "MQ != minMQ for variant-calling."),
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ligation-efficiency",
 *         help="Efficiency of ligation of adapters.",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Efficiency_of_ligation_of_adapte) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":442
 *         "--ligation-efficiency",
 *         help="Efficiency of ligation of adapters.",
 *         type=float)             # <<<<<<<<<<<<<<
 *     InputQtyParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyFloat_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":439
 *               "MQ != minMQ for variant-calling."),
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ligation-efficiency",
 *         help="Efficiency of ligation of adapters.",
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__97, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":443
 *         help="Efficiency of ligation of adapters.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_InputQtyParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__98, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":448
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_RescueShadingParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_fastq_files) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_nargs, __pyx_kp_s__36) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":450
 *     RescueShadingParser.add_argument(
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)             # <<<<<<<<<<<<<<
 *     RescueShadingParser.add_argument(
 *         "--head",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":448
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__99, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":451
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--head",
 *         help=("Number of bases from each read with "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_RescueShadingParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_bases_from_each_read_w) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":455
 *         help=("Number of bases from each read with "
 *               "which to salt the barcode."),
 *         type=int)             # <<<<<<<<<<<<<<
 *     RescueShadingParser.add_argument(
 *         "--mm", help="Mismatch limit",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":451
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--head",
 *         help=("Number of bases from each read with "
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__100, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":456
 *               "which to salt the barcode."),
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mm", help="Mismatch limit",
 *         type=int)
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_RescueShadingParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Mismatch_limit) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":458
 *     RescueShadingParser.add_argument(
 *         "--mm", help="Mismatch limit",
 *         type=int)             # <<<<<<<<<<<<<<
 *     RescueShadingParser.add_argument(
 *         "--minFam", "-m", help="Minimum family size for true families.",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":456
 *               "which to salt the barcode."),
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mm", help="Mismatch limit",
 *         type=int)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__101, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":459
 *         "--mm", help="Mismatch limit",
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minFam", "-m", help="Minimum family size for true families.",
 *         type=int)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_RescueShadingParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_family_size_for_true_fam) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":461
 *     RescueShadingParser.add_argument(
 *         "--minFam", "-m", help="Minimum family size for true families.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     RescueShadingParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":459
 *         "--mm", help="Mismatch limit",
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minFam", "-m", help="Minimum family size for true families.",
 *         type=int)
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__102, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":462
 *         "--minFam", "-m", help="Minimum family size for true families.",
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_RescueShadingParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_a_config_file_If_set_loa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__103, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":467
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inBAM", help="Path to input BAM.")
 *     BedCovParser.add_argument(
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_BedCovParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_input_BAM) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__104, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":469
 *     BedCovParser.add_argument(
 *         "inBAM", help="Path to input BAM.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed", "-b", help="Path to bed over which to calculate coverage.")
 *     BedCovParser.add_argument(
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_BedCovParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_bed_over_which_to_calcul) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__105, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":471
 *     BedCovParser.add_argument(
 *         "--bed", "-b", help="Path to bed over which to calculate coverage.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--threads", "-t", help="Number of threads to use.", type=int)
 *     BedCovParser.add_argument(
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_BedCovParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_threads_to_use) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":472
 *         "--bed", "-b", help="Path to bed over which to calculate coverage.")
 *     BedCovParser.add_argument(
 *         "--threads", "-t", help="Number of threads to use.", type=int)             # <<<<<<<<<<<<<<
 *     BedCovParser.add_argument(
 *         "--FastDOCPath", "-p", help="Path to FastDOC executable jar.")
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":471
 *     BedCovParser.add_argument(
 *         "--bed", "-b", help="Path to bed over which to calculate coverage.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--threads", "-t", help="Number of threads to use.", type=int)
 *     BedCovParser.add_argument(
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__106, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":473
 *     BedCovParser.add_argument(
 *         "--threads", "-t", help="Number of threads to use.", type=int)
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--FastDOCPath", "-p", help="Path to FastDOC executable jar.")
 *     BedCovParser.add_argument(
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_BedCovParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_FastDOC_executable_jar) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__107, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":475
 *     BedCovParser.add_argument(
 *         "--FastDOCPath", "-p", help="Path to FastDOC executable jar.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", "-c", help=("Path to config file. Can be used in place of"
 *                               " any command line arguments."))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_BedCovParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_config_file_Can_be_used) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__108, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":478
 *         "--conf", "-c", help=("Path to config file. Can be used in place of"
 *                               " any command line arguments."))
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed-buffer",
 *         help=("Number of bases in each direction to pad the bed intervals for"
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_BedCovParser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_bases_in_each_directio) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":482
 *         help=("Number of bases in each direction to pad the bed intervals for"
 *               " reads bleeding out into surrounding regions."),
 *         type=int)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument(
 *         'fq',
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":478
 *         "--conf", "-c", help=("Path to config file. Can be used in place of"
 *                               " any command line arguments."))
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed-buffer",
 *         help=("Number of bases in each direction to pad the bed intervals for"
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__109, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":483
 *               " reads bleeding out into surrounding regions."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         'fq',
 *         help="Provide your fastq file(s).",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Provide_your_fastq_file_s) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_nargs, __pyx_kp_s__36) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_reads) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__110, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":488
 *         nargs="+",
 *         metavar=('reads'))
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--idxFastq",
 *         "-i",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_index_fastq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_indexFastq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__111, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":493
 *         help="Path to index fastq",
 *         metavar="indexFastq")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--conf',
 *         help="Path to config file with settings.")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_config_file_with_setting) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__112, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":496
 *         '--conf',
 *         help="Path to config file with settings.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-s',
 *         '--single-end',
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Whether_the_experiment_is_single) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":500
 *         '--single-end',
 *         help="Whether the experiment is single-end or not. Default: False",
 *         type=bool)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument(
 *         '--homing',
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject*)&PyBool_Type)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":496
 *         '--conf',
 *         help="Path to config file with settings.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-s',
 *         '--single-end',
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__113, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":501
 *         help="Whether the experiment is single-end or not. Default: False",
 *         type=bool)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--homing',
 *         help="Homing sequence for samples.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Homing_sequence_for_samples) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_HomingSequence) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__114, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":505
 *         help="Homing sequence for samples.",
 *         metavar=('HomingSequence'))
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--inline-barcodes',
 *         help="Use flag if using inline barcodes method.",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Use_flag_if_using_inline_barcode) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__115, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":509
 *         help="Use flag if using inline barcodes method.",
 *         action="store_true")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-a',
 *         '--aligner',
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Provide_your_aligner_Default_bwa) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_nargs, __pyx_kp_s__117) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_aligner_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__116, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":515
 *         nargs='?',
 *         metavar='aligner')
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-o',
 *         '--opts',
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Additional_aligner_opts_E_g_opts) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__118, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":519
 *         '--opts',
 *         help="Additional aligner opts. E.g.: --opts '-L 0' ")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-b',
 *         '--BAM',
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_BAM_file_if_alignment_has_alread) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__119, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":523
 *         '--BAM',
 *         help="BAM file, if alignment has already run.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--bed',
 *         help="full path to bed file used for variant-calling steps."
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_full_path_to_bed_file_used_for_v) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_metavar, __pyx_n_s_BEDFile) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__120, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":528
 *              "Can be indicated by the config file.",
 *         metavar="BEDFile")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-l',
 *         '--logfile',
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_To_change_default_logfile_locati) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__121, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":532
 *         '--logfile',
 *         help="To change default logfile location.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-p',
 *         '--file-prefix',
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Set_non_default_prefix) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__122, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":536
 *         '--file-prefix',
 *         help="Set non-default prefix.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--minMQ',
 *         help="Minimum mapping quality for variant call inclusion. "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_mapping_quality_for_vari) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":540
 *         help="Minimum mapping quality for variant call inclusion. "
 *              "Can be indicated by the config file.",
 *         type=int)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument(
 *         '--minBQ',
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":536
 *         '--file-prefix',
 *         help="Set non-default prefix.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--minMQ',
 *         help="Minimum mapping quality for variant call inclusion. "
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__123, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":541
 *              "Can be indicated by the config file.",
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--minBQ',
 *         help="Minimum base quality for variant call inclusion. "
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_base_quality_for_variant) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__124, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":545
 *         help="Minimum base quality for variant call inclusion. "
 *              "Can be indicated by the config file.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minCov",
 *         help="Minimum coverage for including a position"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_coverage_for_including_a) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__125, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":549
 *         help="Minimum coverage for including a position"
 *         " in the BamToCoverageBed")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref",
 *         "-r",
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_reference_index_Can_be_i) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__126, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":553
 *         "-r",
 *         help="Path to reference index. Can be indicated by the config file.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--abrapath",
 *         help="Path to abra jar. Can be indicated by the config file.")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_abra_jar_Can_be_indicate) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__127, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":556
 *         "--abrapath",
 *         help="Path to abra jar. Can be indicated by the config file.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--p3Seq", help="3' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_3_primer_sequence_for_cutadapt) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__128, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":558
 *     MainSubparser.add_argument(
 *         "--p3Seq", help="3' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--p5Seq", help="5' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_5_primer_sequence_for_cutadapt) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__129, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":560
 *     MainSubparser.add_argument(
 *         "--p5Seq", help="5' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--review-dir", help="Prefix for review directory, where important re"
 *         "sults files will be moved at the end of analysis.")
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Prefix_for_review_directory_wher) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__130, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":563
 *         "--review-dir", help="Prefix for review directory, where important re"
 *         "sults files will be moved at the end of analysis.")
 *     MainSubparser.add_argument("--minFA", help="Minimum family members agreed on bas"             # <<<<<<<<<<<<<<
 *                         "e for inclusion in variant call", type=int)
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Minimum_family_members_agreed_on) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":564
 *         "sults files will be moved at the end of analysis.")
 *     MainSubparser.add_argument("--minFA", help="Minimum family members agreed on bas"
 *                         "e for inclusion in variant call", type=int)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"
 *                         "r calling PicardTools.")
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":563
 *         "--review-dir", help="Prefix for review directory, where important re"
 *         "sults files will be moved at the end of analysis.")
 *     MainSubparser.add_argument("--minFA", help="Minimum family members agreed on bas"             # <<<<<<<<<<<<<<
 *                         "e for inclusion in variant call", type=int)
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__131, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":565
 *     MainSubparser.add_argument("--minFA", help="Minimum family members agreed on bas"
 *                         "e for inclusion in variant call", type=int)
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"             # <<<<<<<<<<<<<<
 *                         "r calling PicardTools.")
 *     MainSubparser.add_argument("--indelRealigner", help="Select which indel realigne"
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_picard_jar_Required_for) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__132, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":567
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"
 *                         "r calling PicardTools.")
 *     MainSubparser.add_argument("--indelRealigner", help="Select which indel realigne"             # <<<<<<<<<<<<<<
 *                         "r you wish to use. Supported: abra, GATK. Set to "
 *                         "None to avoid realignment.")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Select_which_indel_realigner_you) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__133, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":570
 *                         "r you wish to use. Supported: abra, GATK. Set to "
 *                         "None to avoid realignment.")
 *     MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument("--readLength", help="Read length",
 *                         type=int)
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_GATK_jar_v1_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__134, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":571
 *                         "None to avoid realignment.")
 *     MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")
 *     MainSubparser.add_argument("--readLength", help="Read length",             # <<<<<<<<<<<<<<
 *                         type=int)
 *     MainSubparser.add_argument("--experiment", "-e",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Read_length) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":572
 *     MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")
 *     MainSubparser.add_argument("--readLength", help="Read length",
 *                         type=int)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument("--experiment", "-e",
 *                         help="A comma-joined list of strings with extra infor"
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":571
 *                         "None to avoid realignment.")
 *     MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")
 *     MainSubparser.add_argument("--readLength", help="Read length",             # <<<<<<<<<<<<<<
 *                         type=int)
 *     MainSubparser.add_argument("--experiment", "-e",
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__135, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":573
 *     MainSubparser.add_argument("--readLength", help="Read length",
 *                         type=int)
 *     MainSubparser.add_argument("--experiment", "-e",             # <<<<<<<<<<<<<<
 *                         help="A comma-joined list of strings with extra infor"
 *                         "mation for informing analysis. Currently in beta sup"
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_A_comma_joined_list_of_strings_w) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__136, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":577
 *                         "mation for informing analysis. Currently in beta sup"
 *                         "port: ffpe, amplicon.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--intelDeflator",
 *         help="Path to intel deflator. Speeds up abra calls.")
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Path_to_intel_deflator_Speeds_up) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__137, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":580
 *         "--intelDeflator",
 *         help="Path to intel deflator. Speeds up abra calls.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--sortMem",
 *         help="Memory to use for sorting fastq files. Default: 6G")
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Memory_to_use_for_sorting_fastq) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__138, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":583
 *         "--sortMem",
 *         help="Memory to use for sorting fastq files. Default: 6G")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bcLen",
 *         help=("Length of inline barcodes. Ignored for datasets where "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Length_of_inline_barcodes_Ignore) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":587
 *         help=("Length of inline barcodes. Ignored for datasets where "
 *               "the molecular barcode is on a secondary index."),
 *         type=int)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument(
 *         "--head", help=("Number of bases from the start of reads 1"
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":583
 *         "--sortMem",
 *         help="Memory to use for sorting fastq files. Default: 6G")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bcLen",
 *         help=("Length of inline barcodes. Ignored for datasets where "
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__139, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":588
 *               "the molecular barcode is on a secondary index."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--head", help=("Number of bases from the start of reads 1"
 *                         " and 2 to add to the barcode."),
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Number_of_bases_from_the_start_o) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":591
 *         "--head", help=("Number of bases from the start of reads 1"
 *                         " and 2 to add to the barcode."),
 *         type=int)             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument(
 *         "--parallel",
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyInt_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":588
 *               "the molecular barcode is on a secondary index."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--head", help=("Number of bases from the start of reads 1"
 *                         " and 2 to add to the barcode."),
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__140, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":592
 *                         " and 2 to add to the barcode."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--parallel",
 *         help="Parallelize variant calling activated by this flag.",
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Parallelize_variant_calling_acti) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_action, __pyx_n_s_store_true) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__141, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "utilBMF/bmftools":596
 *         help="Parallelize variant calling activated by this flag.",
 *         action="store_true")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--rescue", type=str,
 *         help="Set to 'true' to add the rescue step to the family merging.")
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_MainSubparser, __pyx_n_s_add_argument); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);

  /* "utilBMF/bmftools":597
 *         action="store_true")
 *     MainSubparser.add_argument(
 *         "--rescue", type=str,             # <<<<<<<<<<<<<<
 *         help="Set to 'true' to add the rescue step to the family merging.")
 *     # for each subparser, add_argument for conf.
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_type, ((PyObject *)((PyObject*)(&PyString_Type)))) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_help, __pyx_kp_s_Set_to_true_to_add_the_rescue_st) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "utilBMF/bmftools":596
 *         help="Parallelize variant calling activated by this flag.",
 *         action="store_true")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--rescue", type=str,
 *         help="Set to 'true' to add the rescue step to the family merging.")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__142, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":604
 * 
 *     # set_trace()
 *     Palin = parser.parse_args()             # <<<<<<<<<<<<<<
 * 
 *     # Global Variables
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser, __pyx_n_s_parse_args); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_Palin = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":608
 *     # Global Variables
 *     global Logger
 *     Logger = logging.getLogger("Primarylogger")             # <<<<<<<<<<<<<<
 *     global Chapman
 *     if(hasattr(Palin, "conf") is False):
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_logging); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_getLogger); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__143, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Logger, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":610
 *     Logger = logging.getLogger("Primarylogger")
 *     global Chapman
 *     if(hasattr(Palin, "conf") is False):             # <<<<<<<<<<<<<<
 *         Palin.conf = None
 *     Chapman = ArgumentSketcher(Palin, Palin.conf)
 */
  __pyx_t_5 = PyObject_HasAttr(__pyx_v_Palin, __pyx_n_s_conf_2); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_6 = ((__pyx_t_5 == 0) != 0);
  if (__pyx_t_6) {

    /* "utilBMF/bmftools":611
 *     global Chapman
 *     if(hasattr(Palin, "conf") is False):
 *         Palin.conf = None             # <<<<<<<<<<<<<<
 *     Chapman = ArgumentSketcher(Palin, Palin.conf)
 *     global Metrics
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_Palin, __pyx_n_s_conf_2, Py_None) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "utilBMF/bmftools":612
 *     if(hasattr(Palin, "conf") is False):
 *         Palin.conf = None
 *     Chapman = ArgumentSketcher(Palin, Palin.conf)             # <<<<<<<<<<<<<<
 *     global Metrics
 *     Metrics = SampleMetrics()
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_ArgumentSketcher); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_Palin, __pyx_n_s_conf_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_7 = 1;
    }
  }
  __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  if (__pyx_t_3) {
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_3); __Pyx_GIVEREF(__pyx_t_3); __pyx_t_3 = NULL;
  }
  __Pyx_INCREF(__pyx_v_Palin);
  PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_v_Palin);
  __Pyx_GIVEREF(__pyx_v_Palin);
  PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_t_4 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Chapman, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":614
 *     Chapman = ArgumentSketcher(Palin, Palin.conf)
 *     global Metrics
 *     Metrics = SampleMetrics()             # <<<<<<<<<<<<<<
 *     global ReviewDirFiles
 *     ReviewDirFiles = ReviewDirComponents()
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_SampleMetrics); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_8 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_8) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Metrics, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":616
 *     Metrics = SampleMetrics()
 *     global ReviewDirFiles
 *     ReviewDirFiles = ReviewDirComponents()             # <<<<<<<<<<<<<<
 * 
 *     #### BEGIN SETUP LOGGING
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_ReviewDirComponents); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_8 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_8) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ReviewDirFiles, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":621
 *     #
 *     # Declare logging style
 *     dateStr = datetime.datetime.now().strftime("%Y-%b-%d,%H-%m-%S")             # <<<<<<<<<<<<<<
 *     # Begin logging
 *     ## Grabs first non "bmftools
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_datetime); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_datetime); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_now); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_8) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_strftime); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__144, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_dateStr = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "utilBMF/bmftools":624
 *     # Begin logging
 *     ## Grabs first non "bmftools
 *     basename = [i for i in sys.argv[2:] if i[0] != "-"][0]             # <<<<<<<<<<<<<<
 *     print("basename: %s" % basename)
 *     return 0
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_argv); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_t_8, 2, 0, NULL, NULL, &__pyx_slice__145, 1, 0, 1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
    __pyx_t_8 = __pyx_t_2; __Pyx_INCREF(__pyx_t_8); __pyx_t_7 = 0;
    __pyx_t_9 = NULL;
  } else {
    __pyx_t_7 = -1; __pyx_t_8 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext; if (unlikely(!__pyx_t_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  for (;;) {
    if (likely(!__pyx_t_9)) {
      if (likely(PyList_CheckExact(__pyx_t_8))) {
        if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_8)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_8, __pyx_t_7); __Pyx_INCREF(__pyx_t_2); __pyx_t_7++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_8, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #endif
      } else {
        if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_8)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_8, __pyx_t_7); __Pyx_INCREF(__pyx_t_2); __pyx_t_7++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_8, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        #endif
      }
    } else {
      __pyx_t_2 = __pyx_t_9(__pyx_t_8);
      if (unlikely(!__pyx_t_2)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_2);
    }
    __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_GetItemInt(__pyx_v_i, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_kp_s__146, Py_NE)); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (__pyx_t_6) {
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_v_i))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = __Pyx_GetItemInt_List(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_basename = __pyx_t_8;
  __pyx_t_8 = 0;

  /* "utilBMF/bmftools":625
 *     ## Grabs first non "bmftools
 *     basename = [i for i in sys.argv[2:] if i[0] != "-"][0]
 *     print("basename: %s" % basename)             # <<<<<<<<<<<<<<
 *     return 0
 *     if(Chapman['logfile'] != "default"):
 */
  __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_basename_s, __pyx_v_basename); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  if (__Pyx_PrintOne(0, __pyx_t_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

  /* "utilBMF/bmftools":626
 *     basename = [i for i in sys.argv[2:] if i[0] != "-"][0]
 *     print("basename: %s" % basename)
 *     return 0             # <<<<<<<<<<<<<<
 *     if(Chapman['logfile'] != "default"):
 *         logfile = Chapman['logfile']
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_int_0);
  __pyx_r = __pyx_int_0;
  goto __pyx_L0;

  /* "utilBMF/bmftools":22
 * 
 * 
 * def main():             # <<<<<<<<<<<<<<
 *     import argparse
 *     parser = argparse.ArgumentParser()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("utilBMF.bmftools.main", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_argparse);
  __Pyx_XDECREF(__pyx_v_parser);
  __Pyx_XDECREF(__pyx_v_subparsers);
  __Pyx_XDECREF(__pyx_v_MainSubparser);
  __Pyx_XDECREF(__pyx_v_BedCovParser);
  __Pyx_XDECREF(__pyx_v_alignTagBamParser);
  __Pyx_XDECREF(__pyx_v_TagBamParser);
  __Pyx_XDECREF(__pyx_v_RescueShadingParser);
  __Pyx_XDECREF(__pyx_v_versionParser);
  __Pyx_XDECREF(__pyx_v_InputQtyParser);
  __Pyx_XDECREF(__pyx_v_PSNVParser);
  __Pyx_XDECREF(__pyx_v_VCFCmpParser);
  __Pyx_XDECREF(__pyx_v_VCFStatsParser);
  __Pyx_XDECREF(__pyx_v_DMultiPlexParser);
  __Pyx_XDECREF(__pyx_v_SNVParser);
  __Pyx_XDECREF(__pyx_v_SVParser);
  __Pyx_XDECREF(__pyx_v_SMAParser);
  __Pyx_XDECREF(__pyx_v_GetUniqueKmerBedParser);
  __Pyx_XDECREF(__pyx_v_FamStatsParser);
  __Pyx_XDECREF(__pyx_v_Palin);
  __Pyx_XDECREF(__pyx_v_dateStr);
  __Pyx_XDECREF(__pyx_v_basename);
  __Pyx_XDECREF(__pyx_v_i);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "bmftools",
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_3_primer_sequence_for_cutadapt, __pyx_k_3_primer_sequence_for_cutadapt, sizeof(__pyx_k_3_primer_sequence_for_cutadapt), 0, 0, 1, 0},
  {&__pyx_kp_s_3_primer_sequence_used_by_cutada, __pyx_k_3_primer_sequence_used_by_cutada, sizeof(__pyx_k_3_primer_sequence_used_by_cutada), 0, 0, 1, 0},
  {&__pyx_kp_s_5_primer_sequence_for_cutadapt, __pyx_k_5_primer_sequence_for_cutadapt, sizeof(__pyx_k_5_primer_sequence_for_cutadapt), 0, 0, 1, 0},
  {&__pyx_kp_s_5_primer_sequence_used_by_cutada, __pyx_k_5_primer_sequence_used_by_cutada, sizeof(__pyx_k_5_primer_sequence_used_by_cutada), 0, 0, 1, 0},
  {&__pyx_kp_s_A_comma_joined_list_of_strings_w, __pyx_k_A_comma_joined_list_of_strings_w, sizeof(__pyx_k_A_comma_joined_list_of_strings_w), 0, 0, 1, 0},
  {&__pyx_kp_s_Additional_aligner_opts_E_g_opts, __pyx_k_Additional_aligner_opts_E_g_opts, sizeof(__pyx_k_Additional_aligner_opts_E_g_opts), 0, 0, 1, 0},
  {&__pyx_kp_s_Aligner_program_e_g_bwa_mem_or_b, __pyx_k_Aligner_program_e_g_bwa_mem_or_b, sizeof(__pyx_k_Aligner_program_e_g_bwa_mem_or_b), 0, 0, 1, 0},
  {&__pyx_n_s_ArgumentParser, __pyx_k_ArgumentParser, sizeof(__pyx_k_ArgumentParser), 0, 0, 1, 1},
  {&__pyx_n_s_ArgumentSketcher, __pyx_k_ArgumentSketcher, sizeof(__pyx_k_ArgumentSketcher), 0, 0, 1, 1},
  {&__pyx_kp_s_BAM, __pyx_k_BAM, sizeof(__pyx_k_BAM), 0, 0, 1, 0},
  {&__pyx_kp_s_BAM_file_if_alignment_has_alread, __pyx_k_BAM_file_if_alignment_has_alread, sizeof(__pyx_k_BAM_file_if_alignment_has_alread), 0, 0, 1, 0},
  {&__pyx_n_s_BEDFile, __pyx_k_BEDFile, sizeof(__pyx_k_BEDFile), 0, 0, 1, 1},
  {&__pyx_n_s_BedCovParser, __pyx_k_BedCovParser, sizeof(__pyx_k_BedCovParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Bed_file_not_used_in_the_alignme, __pyx_k_Bed_file_not_used_in_the_alignme, sizeof(__pyx_k_Bed_file_not_used_in_the_alignme), 0, 0, 1, 0},
  {&__pyx_kp_s_Calculates_the_quantity_of_input, __pyx_k_Calculates_the_quantity_of_input, sizeof(__pyx_k_Calculates_the_quantity_of_input), 0, 0, 1, 0},
  {&__pyx_kp_s_Call_SNVs_Assumes_that_reads_hav, __pyx_k_Call_SNVs_Assumes_that_reads_hav, sizeof(__pyx_k_Call_SNVs_Assumes_that_reads_hav), 0, 0, 1, 0},
  {&__pyx_kp_s_Call_structural_variants_Require, __pyx_k_Call_structural_variants_Require, sizeof(__pyx_k_Call_structural_variants_Require), 0, 0, 1, 0},
  {&__pyx_kp_s_Calls_FastDepthOfCoverage, __pyx_k_Calls_FastDepthOfCoverage, sizeof(__pyx_k_Calls_FastDepthOfCoverage), 0, 0, 1, 0},
  {&__pyx_n_s_Chapman, __pyx_k_Chapman, sizeof(__pyx_k_Chapman), 0, 0, 1, 1},
  {&__pyx_kp_s_Compares_VCF_files, __pyx_k_Compares_VCF_files, sizeof(__pyx_k_Compares_VCF_files), 0, 0, 1, 0},
  {&__pyx_kp_s_Config_file_to_hold_this_so_we_d, __pyx_k_Config_file_to_hold_this_so_we_d, sizeof(__pyx_k_Config_file_to_hold_this_so_we_d), 0, 0, 1, 0},
  {&__pyx_kp_s_Coordinate_Sorted_Indexed_Bam_Fi, __pyx_k_Coordinate_Sorted_Indexed_Bam_Fi, sizeof(__pyx_k_Coordinate_Sorted_Indexed_Bam_Fi), 0, 0, 1, 0},
  {&__pyx_n_s_DMultiPlexParser, __pyx_k_DMultiPlexParser, sizeof(__pyx_k_DMultiPlexParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Desired_mean_family_size, __pyx_k_Desired_mean_family_size, sizeof(__pyx_k_Desired_mean_family_size), 0, 0, 1, 0},
  {&__pyx_kp_s_Distance_around_the_region_of_in, __pyx_k_Distance_around_the_region_of_in, sizeof(__pyx_k_Distance_around_the_region_of_in), 0, 0, 1, 0},
  {&__pyx_kp_s_Efficiency_of_ligation_of_adapte, __pyx_k_Efficiency_of_ligation_of_adapte, sizeof(__pyx_k_Efficiency_of_ligation_of_adapte), 0, 0, 1, 0},
  {&__pyx_kp_s_FM, __pyx_k_FM, sizeof(__pyx_k_FM), 0, 0, 1, 0},
  {&__pyx_n_s_FamStatsParser, __pyx_k_FamStatsParser, sizeof(__pyx_k_FamStatsParser), 0, 0, 1, 1},
  {&__pyx_kp_s_FastDOCPath, __pyx_k_FastDOCPath, sizeof(__pyx_k_FastDOCPath), 0, 0, 1, 0},
  {&__pyx_n_s_FileType, __pyx_k_FileType, sizeof(__pyx_k_FileType), 0, 0, 1, 1},
  {&__pyx_kp_s_Flag_to_perform_barcode_rescue_w, __pyx_k_Flag_to_perform_barcode_rescue_w, sizeof(__pyx_k_Flag_to_perform_barcode_rescue_w), 0, 0, 1, 0},
  {&__pyx_kp_s_Fraction_of_average_read_aligned, __pyx_k_Fraction_of_average_read_aligned, sizeof(__pyx_k_Fraction_of_average_read_aligned), 0, 0, 1, 0},
  {&__pyx_kp_s_Fraction_of_reads_not_usable_due, __pyx_k_Fraction_of_reads_not_usable_due, sizeof(__pyx_k_Fraction_of_reads_not_usable_due), 0, 0, 1, 0},
  {&__pyx_kp_s_Fraction_of_reads_properly_mappe, __pyx_k_Fraction_of_reads_properly_mappe, sizeof(__pyx_k_Fraction_of_reads_properly_mappe), 0, 0, 1, 0},
  {&__pyx_kp_s_Fraction_of_reads_which_are_on_t, __pyx_k_Fraction_of_reads_which_are_on_t, sizeof(__pyx_k_Fraction_of_reads_which_are_on_t), 0, 0, 1, 0},
  {&__pyx_kp_s_Full_path_to_bed_file, __pyx_k_Full_path_to_bed_file, sizeof(__pyx_k_Full_path_to_bed_file), 0, 0, 1, 0},
  {&__pyx_kp_s_Generate_family_size_stats_for_a, __pyx_k_Generate_family_size_stats_for_a, sizeof(__pyx_k_Generate_family_size_stats_for_a), 0, 0, 1, 0},
  {&__pyx_kp_s_Genome_size_for_organism_Default, __pyx_k_Genome_size_for_organism_Default, sizeof(__pyx_k_Genome_size_for_organism_Default), 0, 0, 1, 0},
  {&__pyx_n_s_GetUniqueKmerBedParser, __pyx_k_GetUniqueKmerBedParser, sizeof(__pyx_k_GetUniqueKmerBedParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Gets_counts_and_frequencies_for, __pyx_k_Gets_counts_and_frequencies_for, sizeof(__pyx_k_Gets_counts_and_frequencies_for), 0, 0, 1, 0},
  {&__pyx_n_s_HomingSequence, __pyx_k_HomingSequence, sizeof(__pyx_k_HomingSequence), 0, 0, 1, 1},
  {&__pyx_kp_s_Homing_sequence_for_samples, __pyx_k_Homing_sequence_for_samples, sizeof(__pyx_k_Homing_sequence_for_samples), 0, 0, 1, 0},
  {&__pyx_kp_s_If_set_check_standard_VCF_for_ca, __pyx_k_If_set_check_standard_VCF_for_ca, sizeof(__pyx_k_If_set_check_standard_VCF_for_ca), 0, 0, 1, 0},
  {&__pyx_kp_s_If_set_writes_both_set_compariso, __pyx_k_If_set_writes_both_set_compariso, sizeof(__pyx_k_If_set_writes_both_set_compariso), 0, 0, 1, 0},
  {&__pyx_n_s_InFastqs, __pyx_k_InFastqs, sizeof(__pyx_k_InFastqs), 0, 0, 1, 1},
  {&__pyx_kp_s_Index_Fastq, __pyx_k_Index_Fastq, sizeof(__pyx_k_Index_Fastq), 0, 0, 1, 0},
  {&__pyx_n_s_InputQtyParser, __pyx_k_InputQtyParser, sizeof(__pyx_k_InputQtyParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Input_BAM_Coordinate_sorted_and, __pyx_k_Input_BAM_Coordinate_sorted_and, sizeof(__pyx_k_Input_BAM_Coordinate_sorted_and), 0, 0, 1, 0},
  {&__pyx_kp_s_Input_Fastq_Files, __pyx_k_Input_Fastq_Files, sizeof(__pyx_k_Input_Fastq_Files), 0, 0, 1, 0},
  {&__pyx_kp_s_Input_VCF, __pyx_k_Input_VCF, sizeof(__pyx_k_Input_VCF), 0, 0, 1, 0},
  {&__pyx_kp_s_Input_VCF_as_created_by_SNVCrawl, __pyx_k_Input_VCF_as_created_by_SNVCrawl, sizeof(__pyx_k_Input_VCF_as_created_by_SNVCrawl), 0, 0, 1, 0},
  {&__pyx_kp_s_Length_of_each_read, __pyx_k_Length_of_each_read, sizeof(__pyx_k_Length_of_each_read), 0, 0, 1, 0},
  {&__pyx_kp_s_Length_of_inline_barcodes_Ignore, __pyx_k_Length_of_inline_barcodes_Ignore, sizeof(__pyx_k_Length_of_inline_barcodes_Ignore), 0, 0, 1, 0},
  {&__pyx_kp_s_Length_of_interval_to_be_conside, __pyx_k_Length_of_interval_to_be_conside, sizeof(__pyx_k_Length_of_interval_to_be_conside), 0, 0, 1, 0},
  {&__pyx_kp_s_Length_of_unique_sequence_groups, __pyx_k_Length_of_unique_sequence_groups, sizeof(__pyx_k_Length_of_unique_sequence_groups), 0, 0, 1, 0},
  {&__pyx_n_s_Logger, __pyx_k_Logger, sizeof(__pyx_k_Logger), 0, 0, 1, 1},
  {&__pyx_n_s_MainSubparser, __pyx_k_MainSubparser, sizeof(__pyx_k_MainSubparser), 0, 0, 1, 1},
  {&__pyx_kp_s_Marks_combines_and_processes_a_d, __pyx_k_Marks_combines_and_processes_a_d, sizeof(__pyx_k_Marks_combines_and_processes_a_d), 0, 0, 1, 0},
  {&__pyx_n_s_MawCluster_BCBam, __pyx_k_MawCluster_BCBam, sizeof(__pyx_k_MawCluster_BCBam), 0, 0, 1, 1},
  {&__pyx_kp_s_MaxPValue, __pyx_k_MaxPValue, sizeof(__pyx_k_MaxPValue), 0, 0, 1, 0},
  {&__pyx_kp_s_Maximum_P_value_to_consider_in_e, __pyx_k_Maximum_P_value_to_consider_in_e, sizeof(__pyx_k_Maximum_P_value_to_consider_in_e), 0, 0, 1, 0},
  {&__pyx_kp_s_Maximum_difference_between_edit, __pyx_k_Maximum_difference_between_edit, sizeof(__pyx_k_Maximum_difference_between_edit), 0, 0, 1, 0},
  {&__pyx_kp_s_Memory_to_use_for_sorting_fastq, __pyx_k_Memory_to_use_for_sorting_fastq, sizeof(__pyx_k_Memory_to_use_for_sorting_fastq), 0, 0, 1, 0},
  {&__pyx_n_s_Metrics, __pyx_k_Metrics, sizeof(__pyx_k_Metrics), 0, 0, 1, 1},
  {&__pyx_kp_s_Minimum_Base_Quality_to_consider, __pyx_k_Minimum_Base_Quality_to_consider, sizeof(__pyx_k_Minimum_Base_Quality_to_consider), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_Mapping_Quality_to_consi, __pyx_k_Minimum_Mapping_Quality_to_consi, sizeof(__pyx_k_Minimum_Mapping_Quality_to_consi), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_base_quality_for_inclusi, __pyx_k_Minimum_base_quality_for_inclusi, sizeof(__pyx_k_Minimum_base_quality_for_inclusi), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_base_quality_for_variant, __pyx_k_Minimum_base_quality_for_variant, sizeof(__pyx_k_Minimum_base_quality_for_variant), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_coverage_for_including_a, __pyx_k_Minimum_coverage_for_including_a, sizeof(__pyx_k_Minimum_coverage_for_including_a), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_depth_for_a_cluster_to_b, __pyx_k_Minimum_depth_for_a_cluster_to_b, sizeof(__pyx_k_Minimum_depth_for_a_cluster_to_b), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_family_agreed_on_base, __pyx_k_Minimum_family_agreed_on_base, sizeof(__pyx_k_Minimum_family_agreed_on_base), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_family_members_agreed_on, __pyx_k_Minimum_family_members_agreed_on, sizeof(__pyx_k_Minimum_family_members_agreed_on), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_family_size_for_true_fam, __pyx_k_Minimum_family_size_for_true_fam, sizeof(__pyx_k_Minimum_family_size_for_true_fam), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_fraction_of_reads_in_fam, __pyx_k_Minimum_fraction_of_reads_in_fam, sizeof(__pyx_k_Minimum_fraction_of_reads_in_fam), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_mapping_quality_for_incl, __pyx_k_Minimum_mapping_quality_for_incl, sizeof(__pyx_k_Minimum_mapping_quality_for_incl), 0, 0, 1, 0},
  {&__pyx_kp_s_Minimum_mapping_quality_for_vari, __pyx_k_Minimum_mapping_quality_for_vari, sizeof(__pyx_k_Minimum_mapping_quality_for_vari), 0, 0, 1, 0},
  {&__pyx_kp_s_Mismatch_limit, __pyx_k_Mismatch_limit, sizeof(__pyx_k_Mismatch_limit), 0, 0, 1, 0},
  {&__pyx_kp_s_Name_for_logfile, __pyx_k_Name_for_logfile, sizeof(__pyx_k_Name_for_logfile), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_allowed_mismatches, __pyx_k_Number_of_allowed_mismatches, sizeof(__pyx_k_Number_of_allowed_mismatches), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_bases_from_each_read_w, __pyx_k_Number_of_bases_from_each_read_w, sizeof(__pyx_k_Number_of_bases_from_each_read_w), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_bases_from_the_start_o, __pyx_k_Number_of_bases_from_the_start_o, sizeof(__pyx_k_Number_of_bases_from_the_start_o), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_bases_in_each_directio, __pyx_k_Number_of_bases_in_each_directio, sizeof(__pyx_k_Number_of_bases_in_each_directio), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_template_molecules_seq, __pyx_k_Number_of_template_molecules_seq, sizeof(__pyx_k_Number_of_template_molecules_seq), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_threads, __pyx_k_Number_of_threads, sizeof(__pyx_k_Number_of_threads), 0, 0, 1, 0},
  {&__pyx_kp_s_Number_of_threads_to_use, __pyx_k_Number_of_threads_to_use, sizeof(__pyx_k_Number_of_threads_to_use), 0, 0, 1, 0},
  {&__pyx_n_s_OutputVCF, __pyx_k_OutputVCF, sizeof(__pyx_k_OutputVCF), 0, 0, 1, 1},
  {&__pyx_kp_s_Output_VCF_File, __pyx_k_Output_VCF_File, sizeof(__pyx_k_Output_VCF_File), 0, 0, 1, 0},
  {&__pyx_kp_s_Output_VCF_If_unset_defaults_to, __pyx_k_Output_VCF_If_unset_defaults_to, sizeof(__pyx_k_Output_VCF_If_unset_defaults_to), 0, 0, 1, 0},
  {&__pyx_kp_s_Output_tsv, __pyx_k_Output_tsv, sizeof(__pyx_k_Output_tsv), 0, 0, 1, 0},
  {&__pyx_kp_s_Outputs_version_of_BMFTools, __pyx_k_Outputs_version_of_BMFTools, sizeof(__pyx_k_Outputs_version_of_BMFTools), 0, 0, 1, 0},
  {&__pyx_n_s_PSNVParser, __pyx_k_PSNVParser, sizeof(__pyx_k_PSNVParser), 0, 0, 1, 1},
  {&__pyx_n_s_Palin, __pyx_k_Palin, sizeof(__pyx_k_Palin), 0, 0, 1, 1},
  {&__pyx_kp_s_Parallel_SNV_calls, __pyx_k_Parallel_SNV_calls, sizeof(__pyx_k_Parallel_SNV_calls), 0, 0, 1, 0},
  {&__pyx_kp_s_Parallelize_variant_calling_acti, __pyx_k_Parallelize_variant_calling_acti, sizeof(__pyx_k_Parallelize_variant_calling_acti), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_FastDOC_executable_jar, __pyx_k_Path_to_FastDOC_executable_jar, sizeof(__pyx_k_Path_to_FastDOC_executable_jar), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_GATK_jar_v1_6, __pyx_k_Path_to_GATK_jar_v1_6, sizeof(__pyx_k_Path_to_GATK_jar_v1_6), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_a_config_file_If_set_loa, __pyx_k_Path_to_a_config_file_If_set_loa, sizeof(__pyx_k_Path_to_a_config_file_If_set_loa), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_abra_jar_Can_be_indicate, __pyx_k_Path_to_abra_jar_Can_be_indicate, sizeof(__pyx_k_Path_to_abra_jar_Can_be_indicate), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_bed_over_which_to_calcul, __pyx_k_Path_to_bed_over_which_to_calcul, sizeof(__pyx_k_Path_to_bed_over_which_to_calcul), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_bedfile, __pyx_k_Path_to_bedfile, sizeof(__pyx_k_Path_to_bedfile), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_config_file_Can_be_used, __pyx_k_Path_to_config_file_Can_be_used, sizeof(__pyx_k_Path_to_config_file_Can_be_used), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_config_file_with_setting, __pyx_k_Path_to_config_file_with_setting, sizeof(__pyx_k_Path_to_config_file_with_setting), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_fastq_files, __pyx_k_Path_to_fastq_files, sizeof(__pyx_k_Path_to_fastq_files), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_flattened_fastq_file, __pyx_k_Path_to_flattened_fastq_file, sizeof(__pyx_k_Path_to_flattened_fastq_file), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_index_fastq, __pyx_k_Path_to_index_fastq, sizeof(__pyx_k_Path_to_index_fastq), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_input_BAM, __pyx_k_Path_to_input_BAM, sizeof(__pyx_k_Path_to_input_BAM), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_input_bed_file_defining, __pyx_k_Path_to_input_bed_file_defining, sizeof(__pyx_k_Path_to_input_bed_file_defining), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_intel_deflator_Speeds_up, __pyx_k_Path_to_intel_deflator_Speeds_up, sizeof(__pyx_k_Path_to_intel_deflator_Speeds_up), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_output_bed_file, __pyx_k_Path_to_output_bed_file, sizeof(__pyx_k_Path_to_output_bed_file), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_output_file_Default_stdo, __pyx_k_Path_to_output_file_Default_stdo, sizeof(__pyx_k_Path_to_output_file_Default_stdo), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_output_file_If_not_set_d, __pyx_k_Path_to_output_file_If_not_set_d, sizeof(__pyx_k_Path_to_output_file_If_not_set_d), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_picard_jar_Required_for, __pyx_k_Path_to_picard_jar_Required_for, sizeof(__pyx_k_Path_to_picard_jar_Required_for), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_reference_file_Must_be_f, __pyx_k_Path_to_reference_file_Must_be_f, sizeof(__pyx_k_Path_to_reference_file_Must_be_f), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_reference_index, __pyx_k_Path_to_reference_index, sizeof(__pyx_k_Path_to_reference_index), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_reference_index_Can_be_i, __pyx_k_Path_to_reference_index_Can_be_i, sizeof(__pyx_k_Path_to_reference_index_Can_be_i), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_the_GATK_Jar, __pyx_k_Path_to_the_GATK_Jar, sizeof(__pyx_k_Path_to_the_GATK_Jar), 0, 0, 1, 0},
  {&__pyx_kp_s_Path_to_the_abra_realigner_progr, __pyx_k_Path_to_the_abra_realigner_progr, sizeof(__pyx_k_Path_to_the_abra_realigner_progr), 0, 0, 1, 0},
  {&__pyx_kp_s_Performs_alignment_and_sam_taggi, __pyx_k_Performs_alignment_and_sam_taggi, sizeof(__pyx_k_Performs_alignment_and_sam_taggi), 0, 0, 1, 0},
  {&__pyx_kp_s_Prefix_for_review_directory_wher, __pyx_k_Prefix_for_review_directory_wher, sizeof(__pyx_k_Prefix_for_review_directory_wher), 0, 0, 1, 0},
  {&__pyx_n_s_Primarylogger, __pyx_k_Primarylogger, sizeof(__pyx_k_Primarylogger), 0, 0, 1, 1},
  {&__pyx_kp_s_Provide_reference_fasta, __pyx_k_Provide_reference_fasta, sizeof(__pyx_k_Provide_reference_fasta), 0, 0, 1, 0},
  {&__pyx_kp_s_Provide_your_aligner_Default_bwa, __pyx_k_Provide_your_aligner_Default_bwa, sizeof(__pyx_k_Provide_your_aligner_Default_bwa), 0, 0, 1, 0},
  {&__pyx_kp_s_Provide_your_fastq_file_s, __pyx_k_Provide_your_fastq_file_s, sizeof(__pyx_k_Provide_your_fastq_file_s), 0, 0, 1, 0},
  {&__pyx_kp_s_Query_VCF_to_compare_to_referenc, __pyx_k_Query_VCF_to_compare_to_referenc, sizeof(__pyx_k_Query_VCF_to_compare_to_referenc), 0, 0, 1, 0},
  {&__pyx_kp_s_Read_length, __pyx_k_Read_length, sizeof(__pyx_k_Read_length), 0, 0, 1, 0},
  {&__pyx_kp_s_Read_length_for_abra_KmerSizeEva, __pyx_k_Read_length_for_abra_KmerSizeEva, sizeof(__pyx_k_Read_length_for_abra_KmerSizeEva), 0, 0, 1, 0},
  {&__pyx_kp_s_Realigner_program_e_g_abra_or_ga, __pyx_k_Realigner_program_e_g_abra_or_ga, sizeof(__pyx_k_Realigner_program_e_g_abra_or_ga), 0, 0, 1, 0},
  {&__pyx_kp_s_Reference_FASTA_to_align_fastqs, __pyx_k_Reference_FASTA_to_align_fastqs, sizeof(__pyx_k_Reference_FASTA_to_align_fastqs), 0, 0, 1, 0},
  {&__pyx_kp_s_Reference_VCF_for_comparing_to_q, __pyx_k_Reference_VCF_for_comparing_to_q, sizeof(__pyx_k_Reference_VCF_for_comparing_to_q), 0, 0, 1, 0},
  {&__pyx_n_s_RescueShadingParser, __pyx_k_RescueShadingParser, sizeof(__pyx_k_RescueShadingParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Rescue_fastq_shading, __pyx_k_Rescue_fastq_shading, sizeof(__pyx_k_Rescue_fastq_shading), 0, 0, 1, 0},
  {&__pyx_n_s_ReviewDirComponents, __pyx_k_ReviewDirComponents, sizeof(__pyx_k_ReviewDirComponents), 0, 0, 1, 1},
  {&__pyx_n_s_ReviewDirFiles, __pyx_k_ReviewDirFiles, sizeof(__pyx_k_ReviewDirFiles), 0, 0, 1, 1},
  {&__pyx_kp_s_Run_a_full_pipeline_analysis, __pyx_k_Run_a_full_pipeline_analysis, sizeof(__pyx_k_Run_a_full_pipeline_analysis), 0, 0, 1, 0},
  {&__pyx_n_s_SMAParser, __pyx_k_SMAParser, sizeof(__pyx_k_SMAParser), 0, 0, 1, 1},
  {&__pyx_n_s_SNVParser, __pyx_k_SNVParser, sizeof(__pyx_k_SNVParser), 0, 0, 1, 1},
  {&__pyx_n_s_SVParser, __pyx_k_SVParser, sizeof(__pyx_k_SVParser), 0, 0, 1, 1},
  {&__pyx_n_s_SampleMetrics, __pyx_k_SampleMetrics, sizeof(__pyx_k_SampleMetrics), 0, 0, 1, 1},
  {&__pyx_kp_s_Select_which_indel_realigner_you, __pyx_k_Select_which_indel_realigner_you, sizeof(__pyx_k_Select_which_indel_realigner_you), 0, 0, 1, 0},
  {&__pyx_kp_s_Set_non_default_prefix, __pyx_k_Set_non_default_prefix, sizeof(__pyx_k_Set_non_default_prefix), 0, 0, 1, 0},
  {&__pyx_kp_s_Set_output_file_path_instead_of, __pyx_k_Set_output_file_path_instead_of, sizeof(__pyx_k_Set_output_file_path_instead_of), 0, 0, 1, 0},
  {&__pyx_kp_s_Set_this_flag_if_the_data_is_pai, __pyx_k_Set_this_flag_if_the_data_is_pai, sizeof(__pyx_k_Set_this_flag_if_the_data_is_pai), 0, 0, 1, 0},
  {&__pyx_kp_s_Set_to_true_to_add_the_rescue_st, __pyx_k_Set_to_true_to_add_the_rescue_st, sizeof(__pyx_k_Set_to_true_to_add_the_rescue_st), 0, 0, 1, 0},
  {&__pyx_kp_s_Size_of_capture_region_in_number, __pyx_k_Size_of_capture_region_in_number, sizeof(__pyx_k_Size_of_capture_region_in_number), 0, 0, 1, 0},
  {&__pyx_n_s_TagBamParser, __pyx_k_TagBamParser, sizeof(__pyx_k_TagBamParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Tag_a_BAM_file_with_appropriate, __pyx_k_Tag_a_BAM_file_with_appropriate, sizeof(__pyx_k_Tag_a_BAM_file_with_appropriate), 0, 0, 1, 0},
  {&__pyx_kp_s_Tag_to_append_to_the_output_VCF, __pyx_k_Tag_to_append_to_the_output_VCF, sizeof(__pyx_k_Tag_to_append_to_the_output_VCF), 0, 0, 1, 0},
  {&__pyx_kp_s_Tagged_Merged_Fastq_File_s, __pyx_k_Tagged_Merged_Fastq_File_s, sizeof(__pyx_k_Tagged_Merged_Fastq_File_s), 0, 0, 1, 0},
  {&__pyx_kp_s_To_change_default_logfile_locati, __pyx_k_To_change_default_logfile_locati, sizeof(__pyx_k_To_change_default_logfile_locati), 0, 0, 1, 0},
  {&__pyx_kp_s_Tool_for_selecting_kmers_which_a, __pyx_k_Tool_for_selecting_kmers_which_a, sizeof(__pyx_k_Tool_for_selecting_kmers_which_a), 0, 0, 1, 0},
  {&__pyx_kp_s_Tool_for_splitting_a_VCF_File_wi, __pyx_k_Tool_for_splitting_a_VCF_File_wi, sizeof(__pyx_k_Tool_for_splitting_a_VCF_File_wi), 0, 0, 1, 0},
  {&__pyx_n_s_TrimExt, __pyx_k_TrimExt, sizeof(__pyx_k_TrimExt), 0, 0, 1, 1},
  {&__pyx_kp_s_Untagged_Bam_name_sorted, __pyx_k_Untagged_Bam_name_sorted, sizeof(__pyx_k_Untagged_Bam_name_sorted), 0, 0, 1, 0},
  {&__pyx_kp_s_Use_flag_if_using_inline_barcode, __pyx_k_Use_flag_if_using_inline_barcode, sizeof(__pyx_k_Use_flag_if_using_inline_barcode), 0, 0, 1, 0},
  {&__pyx_n_s_VCFCmpParser, __pyx_k_VCFCmpParser, sizeof(__pyx_k_VCFCmpParser), 0, 0, 1, 1},
  {&__pyx_n_s_VCFStatsParser, __pyx_k_VCFStatsParser, sizeof(__pyx_k_VCFStatsParser), 0, 0, 1, 1},
  {&__pyx_kp_s_Whether_or_not_SNVCrawler_is_sla, __pyx_k_Whether_or_not_SNVCrawler_is_sla, sizeof(__pyx_k_Whether_or_not_SNVCrawler_is_sla), 0, 0, 1, 0},
  {&__pyx_kp_s_Whether_or_not_to_count_copies_o, __pyx_k_Whether_or_not_to_count_copies_o, sizeof(__pyx_k_Whether_or_not_to_count_copies_o), 0, 0, 1, 0},
  {&__pyx_kp_s_Whether_the_experiment_is_single, __pyx_k_Whether_the_experiment_is_single, sizeof(__pyx_k_Whether_the_experiment_is_single), 0, 0, 1, 0},
  {&__pyx_kp_s_Y_b_d_H_m_S, __pyx_k_Y_b_d_H_m_S, sizeof(__pyx_k_Y_b_d_H_m_S), 0, 0, 1, 0},
  {&__pyx_kp_s__117, __pyx_k__117, sizeof(__pyx_k__117), 0, 0, 1, 0},
  {&__pyx_kp_s__146, __pyx_k__146, sizeof(__pyx_k__146), 0, 0, 1, 0},
  {&__pyx_kp_s__36, __pyx_k__36, sizeof(__pyx_k__36), 0, 0, 1, 0},
  {&__pyx_kp_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 0},
  {&__pyx_kp_s_abrapath, __pyx_k_abrapath, sizeof(__pyx_k_abrapath), 0, 0, 1, 0},
  {&__pyx_n_s_abrapath_2, __pyx_k_abrapath_2, sizeof(__pyx_k_abrapath_2), 0, 0, 1, 1},
  {&__pyx_n_s_action, __pyx_k_action, sizeof(__pyx_k_action), 0, 0, 1, 1},
  {&__pyx_n_s_add_argument, __pyx_k_add_argument, sizeof(__pyx_k_add_argument), 0, 0, 1, 1},
  {&__pyx_n_s_add_parser, __pyx_k_add_parser, sizeof(__pyx_k_add_parser), 0, 0, 1, 1},
  {&__pyx_n_s_add_subparsers, __pyx_k_add_subparsers, sizeof(__pyx_k_add_subparsers), 0, 0, 1, 1},
  {&__pyx_n_s_alignTagBamParser, __pyx_k_alignTagBamParser, sizeof(__pyx_k_alignTagBamParser), 0, 0, 1, 1},
  {&__pyx_kp_s_aligner, __pyx_k_aligner, sizeof(__pyx_k_aligner), 0, 0, 1, 0},
  {&__pyx_n_s_aligner_2, __pyx_k_aligner_2, sizeof(__pyx_k_aligner_2), 0, 0, 1, 1},
  {&__pyx_n_s_aligntagbam, __pyx_k_aligntagbam, sizeof(__pyx_k_aligntagbam), 0, 0, 1, 1},
  {&__pyx_kp_s_analysisTag, __pyx_k_analysisTag, sizeof(__pyx_k_analysisTag), 0, 0, 1, 0},
  {&__pyx_n_s_argparse, __pyx_k_argparse, sizeof(__pyx_k_argparse), 0, 0, 1, 1},
  {&__pyx_n_s_argv, __pyx_k_argv, sizeof(__pyx_k_argv), 0, 0, 1, 1},
  {&__pyx_kp_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 0},
  {&__pyx_n_s_bam, __pyx_k_bam, sizeof(__pyx_k_bam), 0, 0, 1, 1},
  {&__pyx_n_s_basename, __pyx_k_basename, sizeof(__pyx_k_basename), 0, 0, 1, 1},
  {&__pyx_kp_s_basename_s, __pyx_k_basename_s, sizeof(__pyx_k_basename_s), 0, 0, 1, 0},
  {&__pyx_kp_s_bcLen, __pyx_k_bcLen, sizeof(__pyx_k_bcLen), 0, 0, 1, 0},
  {&__pyx_kp_s_bed, __pyx_k_bed, sizeof(__pyx_k_bed), 0, 0, 1, 0},
  {&__pyx_n_s_bed_2, __pyx_k_bed_2, sizeof(__pyx_k_bed_2), 0, 0, 1, 1},
  {&__pyx_kp_s_bed_buffer, __pyx_k_bed_buffer, sizeof(__pyx_k_bed_buffer), 0, 0, 1, 0},
  {&__pyx_n_s_bedcov, __pyx_k_bedcov, sizeof(__pyx_k_bedcov), 0, 0, 1, 1},
  {&__pyx_n_s_bedpath, __pyx_k_bedpath, sizeof(__pyx_k_bedpath), 0, 0, 1, 1},
  {&__pyx_n_s_bmfsuites, __pyx_k_bmfsuites, sizeof(__pyx_k_bmfsuites), 0, 0, 1, 1},
  {&__pyx_kp_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 0},
  {&__pyx_kp_s_check_both, __pyx_k_check_both, sizeof(__pyx_k_check_both), 0, 0, 1, 0},
  {&__pyx_kp_s_check_std, __pyx_k_check_std, sizeof(__pyx_k_check_std), 0, 0, 1, 0},
  {&__pyx_kp_s_conf, __pyx_k_conf, sizeof(__pyx_k_conf), 0, 0, 1, 0},
  {&__pyx_n_s_conf_2, __pyx_k_conf_2, sizeof(__pyx_k_conf_2), 0, 0, 1, 1},
  {&__pyx_kp_s_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 0, 1, 0},
  {&__pyx_n_s_dateStr, __pyx_k_dateStr, sizeof(__pyx_k_dateStr), 0, 0, 1, 1},
  {&__pyx_n_s_datetime, __pyx_k_datetime, sizeof(__pyx_k_datetime), 0, 0, 1, 1},
  {&__pyx_n_s_default, __pyx_k_default, sizeof(__pyx_k_default), 0, 0, 1, 1},
  {&__pyx_n_s_description, __pyx_k_description, sizeof(__pyx_k_description), 0, 0, 1, 1},
  {&__pyx_n_s_dest, __pyx_k_dest, sizeof(__pyx_k_dest), 0, 0, 1, 1},
  {&__pyx_n_s_dmp, __pyx_k_dmp, sizeof(__pyx_k_dmp), 0, 0, 1, 1},
  {&__pyx_kp_s_e, __pyx_k_e, sizeof(__pyx_k_e), 0, 0, 1, 0},
  {&__pyx_n_s_end, __pyx_k_end, sizeof(__pyx_k_end), 0, 0, 1, 1},
  {&__pyx_n_s_exit, __pyx_k_exit, sizeof(__pyx_k_exit), 0, 0, 1, 1},
  {&__pyx_kp_s_experiment, __pyx_k_experiment, sizeof(__pyx_k_experiment), 0, 0, 1, 0},
  {&__pyx_kp_s_f, __pyx_k_f, sizeof(__pyx_k_f), 0, 0, 1, 0},
  {&__pyx_n_s_famstats, __pyx_k_famstats, sizeof(__pyx_k_famstats), 0, 0, 1, 1},
  {&__pyx_kp_s_fastq, __pyx_k_fastq, sizeof(__pyx_k_fastq), 0, 0, 1, 0},
  {&__pyx_kp_s_fastqs, __pyx_k_fastqs, sizeof(__pyx_k_fastqs), 0, 0, 1, 0},
  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
  {&__pyx_kp_s_file_prefix, __pyx_k_file_prefix, sizeof(__pyx_k_file_prefix), 0, 0, 1, 0},
  {&__pyx_n_s_fq, __pyx_k_fq, sizeof(__pyx_k_fq), 0, 0, 1, 1},
  {&__pyx_kp_s_full_path_to_bed_file_used_for_v, __pyx_k_full_path_to_bed_file_used_for_v, sizeof(__pyx_k_full_path_to_bed_file_used_for_v), 0, 0, 1, 0},
  {&__pyx_kp_s_g, __pyx_k_g, sizeof(__pyx_k_g), 0, 0, 1, 0},
  {&__pyx_n_s_gatk, __pyx_k_gatk, sizeof(__pyx_k_gatk), 0, 0, 1, 1},
  {&__pyx_kp_s_gatkpath, __pyx_k_gatkpath, sizeof(__pyx_k_gatkpath), 0, 0, 1, 0},
  {&__pyx_kp_s_genome_size, __pyx_k_genome_size, sizeof(__pyx_k_genome_size), 0, 0, 1, 0},
  {&__pyx_n_s_getLogger, __pyx_k_getLogger, sizeof(__pyx_k_getLogger), 0, 0, 1, 1},
  {&__pyx_n_s_getuniquekmersbed, __pyx_k_getuniquekmersbed, sizeof(__pyx_k_getuniquekmersbed), 0, 0, 1, 1},
  {&__pyx_kp_s_head, __pyx_k_head, sizeof(__pyx_k_head), 0, 0, 1, 0},
  {&__pyx_n_s_help, __pyx_k_help, sizeof(__pyx_k_help), 0, 0, 1, 1},
  {&__pyx_kp_s_homing, __pyx_k_homing, sizeof(__pyx_k_homing), 0, 0, 1, 0},
  {&__pyx_kp_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 0},
  {&__pyx_n_s_i_2, __pyx_k_i_2, sizeof(__pyx_k_i_2), 0, 0, 1, 1},
  {&__pyx_kp_s_idxFastq, __pyx_k_idxFastq, sizeof(__pyx_k_idxFastq), 0, 0, 1, 0},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_inBAM, __pyx_k_inBAM, sizeof(__pyx_k_inBAM), 0, 0, 1, 1},
  {&__pyx_n_s_inFq, __pyx_k_inFq, sizeof(__pyx_k_inFq), 0, 0, 1, 1},
  {&__pyx_n_s_inFqs, __pyx_k_inFqs, sizeof(__pyx_k_inFqs), 0, 0, 1, 1},
  {&__pyx_n_s_inVCF, __pyx_k_inVCF, sizeof(__pyx_k_inVCF), 0, 0, 1, 1},
  {&__pyx_kp_s_inbed, __pyx_k_inbed, sizeof(__pyx_k_inbed), 0, 0, 1, 0},
  {&__pyx_n_s_inbed_2, __pyx_k_inbed_2, sizeof(__pyx_k_inbed_2), 0, 0, 1, 1},
  {&__pyx_kp_s_indelRealigner, __pyx_k_indelRealigner, sizeof(__pyx_k_indelRealigner), 0, 0, 1, 0},
  {&__pyx_n_s_indexFastq, __pyx_k_indexFastq, sizeof(__pyx_k_indexFastq), 0, 0, 1, 1},
  {&__pyx_kp_s_indexFq, __pyx_k_indexFq, sizeof(__pyx_k_indexFq), 0, 0, 1, 0},
  {&__pyx_kp_s_inline_barcodes, __pyx_k_inline_barcodes, sizeof(__pyx_k_inline_barcodes), 0, 0, 1, 0},
  {&__pyx_kp_s_insert_distance, __pyx_k_insert_distance, sizeof(__pyx_k_insert_distance), 0, 0, 1, 0},
  {&__pyx_kp_s_intelDeflator, __pyx_k_intelDeflator, sizeof(__pyx_k_intelDeflator), 0, 0, 1, 0},
  {&__pyx_kp_s_is_slave, __pyx_k_is_slave, sizeof(__pyx_k_is_slave), 0, 0, 1, 0},
  {&__pyx_kp_s_k, __pyx_k_k, sizeof(__pyx_k_k), 0, 0, 1, 0},
  {&__pyx_kp_s_keepConsensus, __pyx_k_keepConsensus, sizeof(__pyx_k_keepConsensus), 0, 0, 1, 0},
  {&__pyx_kp_s_kmer, __pyx_k_kmer, sizeof(__pyx_k_kmer), 0, 0, 1, 0},
  {&__pyx_n_s_kmer_2, __pyx_k_kmer_2, sizeof(__pyx_k_kmer_2), 0, 0, 1, 1},
  {&__pyx_kp_s_l, __pyx_k_l, sizeof(__pyx_k_l), 0, 0, 1, 0},
  {&__pyx_kp_s_ligation_efficiency, __pyx_k_ligation_efficiency, sizeof(__pyx_k_ligation_efficiency), 0, 0, 1, 0},
  {&__pyx_kp_s_logfile, __pyx_k_logfile, sizeof(__pyx_k_logfile), 0, 0, 1, 0},
  {&__pyx_n_s_logging, __pyx_k_logging, sizeof(__pyx_k_logging), 0, 0, 1, 1},
  {&__pyx_kp_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 0},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_main_2, __pyx_k_main_2, sizeof(__pyx_k_main_2), 0, 0, 1, 1},
  {&__pyx_kp_s_mapped_fraction, __pyx_k_mapped_fraction, sizeof(__pyx_k_mapped_fraction), 0, 0, 1, 0},
  {&__pyx_kp_s_mean_aligned_fraction, __pyx_k_mean_aligned_fraction, sizeof(__pyx_k_mean_aligned_fraction), 0, 0, 1, 0},
  {&__pyx_n_s_metavar, __pyx_k_metavar, sizeof(__pyx_k_metavar), 0, 0, 1, 1},
  {&__pyx_kp_s_minBQ, __pyx_k_minBQ, sizeof(__pyx_k_minBQ), 0, 0, 1, 0},
  {&__pyx_kp_s_minClustDepth, __pyx_k_minClustDepth, sizeof(__pyx_k_minClustDepth), 0, 0, 1, 0},
  {&__pyx_kp_s_minCov, __pyx_k_minCov, sizeof(__pyx_k_minCov), 0, 0, 1, 0},
  {&__pyx_kp_s_minFA, __pyx_k_minFA, sizeof(__pyx_k_minFA), 0, 0, 1, 0},
  {&__pyx_kp_s_minFam, __pyx_k_minFam, sizeof(__pyx_k_minFam), 0, 0, 1, 0},
  {&__pyx_kp_s_minFracAgreed, __pyx_k_minFracAgreed, sizeof(__pyx_k_minFracAgreed), 0, 0, 1, 0},
  {&__pyx_kp_s_minMQ, __pyx_k_minMQ, sizeof(__pyx_k_minMQ), 0, 0, 1, 0},
  {&__pyx_kp_s_minPileupLen, __pyx_k_minPileupLen, sizeof(__pyx_k_minPileupLen), 0, 0, 1, 0},
  {&__pyx_kp_s_mismatches, __pyx_k_mismatches, sizeof(__pyx_k_mismatches), 0, 0, 1, 0},
  {&__pyx_n_s_mismatches_2, __pyx_k_mismatches_2, sizeof(__pyx_k_mismatches_2), 0, 0, 1, 1},
  {&__pyx_kp_s_mm, __pyx_k_mm, sizeof(__pyx_k_mm), 0, 0, 1, 0},
  {&__pyx_kp_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 0},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_nargs, __pyx_k_nargs, sizeof(__pyx_k_nargs), 0, 0, 1, 1},
  {&__pyx_kp_s_no_strand_correction, __pyx_k_no_strand_correction, sizeof(__pyx_k_no_strand_correction), 0, 0, 1, 0},
  {&__pyx_n_s_now, __pyx_k_now, sizeof(__pyx_k_now), 0, 0, 1, 1},
  {&__pyx_kp_s_number_of_templates, __pyx_k_number_of_templates, sizeof(__pyx_k_number_of_templates), 0, 0, 1, 0},
  {&__pyx_kp_s_o, __pyx_k_o, sizeof(__pyx_k_o), 0, 0, 1, 0},
  {&__pyx_kp_s_on_target, __pyx_k_on_target, sizeof(__pyx_k_on_target), 0, 0, 1, 0},
  {&__pyx_kp_s_opts, __pyx_k_opts, sizeof(__pyx_k_opts), 0, 0, 1, 0},
  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
  {&__pyx_n_s_ospath, __pyx_k_ospath, sizeof(__pyx_k_ospath), 0, 0, 1, 1},
  {&__pyx_kp_s_outTsv, __pyx_k_outTsv, sizeof(__pyx_k_outTsv), 0, 0, 1, 0},
  {&__pyx_kp_s_outVCF, __pyx_k_outVCF, sizeof(__pyx_k_outVCF), 0, 0, 1, 0},
  {&__pyx_kp_s_outbed, __pyx_k_outbed, sizeof(__pyx_k_outbed), 0, 0, 1, 0},
  {&__pyx_n_s_outbed_2, __pyx_k_outbed_2, sizeof(__pyx_k_outbed_2), 0, 0, 1, 1},
  {&__pyx_kp_s_outfile, __pyx_k_outfile, sizeof(__pyx_k_outfile), 0, 0, 1, 0},
  {&__pyx_kp_s_outfile_handle, __pyx_k_outfile_handle, sizeof(__pyx_k_outfile_handle), 0, 0, 1, 0},
  {&__pyx_kp_s_p, __pyx_k_p, sizeof(__pyx_k_p), 0, 0, 1, 0},
  {&__pyx_kp_s_p3Seq, __pyx_k_p3Seq, sizeof(__pyx_k_p3Seq), 0, 0, 1, 0},
  {&__pyx_kp_s_p5Seq, __pyx_k_p5Seq, sizeof(__pyx_k_p5Seq), 0, 0, 1, 0},
  {&__pyx_kp_s_padding, __pyx_k_padding, sizeof(__pyx_k_padding), 0, 0, 1, 0},
  {&__pyx_kp_s_paired, __pyx_k_paired, sizeof(__pyx_k_paired), 0, 0, 1, 0},
  {&__pyx_n_s_pairedBarcodeTagging, __pyx_k_pairedBarcodeTagging, sizeof(__pyx_k_pairedBarcodeTagging), 0, 0, 1, 1},
  {&__pyx_kp_s_parallel, __pyx_k_parallel, sizeof(__pyx_k_parallel), 0, 0, 1, 0},
  {&__pyx_n_s_parse_args, __pyx_k_parse_args, sizeof(__pyx_k_parse_args), 0, 0, 1, 1},
  {&__pyx_n_s_parser, __pyx_k_parser, sizeof(__pyx_k_parser), 0, 0, 1, 1},
  {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
  {&__pyx_kp_s_picardpath, __pyx_k_picardpath, sizeof(__pyx_k_picardpath), 0, 0, 1, 0},
  {&__pyx_n_s_pl, __pyx_k_pl, sizeof(__pyx_k_pl), 0, 0, 1, 1},
  {&__pyx_n_s_primer3Seq, __pyx_k_primer3Seq, sizeof(__pyx_k_primer3Seq), 0, 0, 1, 1},
  {&__pyx_n_s_primer5Seq, __pyx_k_primer5Seq, sizeof(__pyx_k_primer5Seq), 0, 0, 1, 1},
  {&__pyx_n_s_print, __pyx_k_print, sizeof(__pyx_k_print), 0, 0, 1, 1},
  {&__pyx_n_s_printlog, __pyx_k_printlog, sizeof(__pyx_k_printlog), 0, 0, 1, 1},
  {&__pyx_n_s_psnv, __pyx_k_psnv, sizeof(__pyx_k_psnv), 0, 0, 1, 1},
  {&__pyx_kp_s_qc_fail, __pyx_k_qc_fail, sizeof(__pyx_k_qc_fail), 0, 0, 1, 0},
  {&__pyx_n_s_qty, __pyx_k_qty, sizeof(__pyx_k_qty), 0, 0, 1, 1},
  {&__pyx_n_s_queryVCF, __pyx_k_queryVCF, sizeof(__pyx_k_queryVCF), 0, 0, 1, 1},
  {&__pyx_kp_s_r, __pyx_k_r, sizeof(__pyx_k_r), 0, 0, 1, 0},
  {&__pyx_kp_s_readLength, __pyx_k_readLength, sizeof(__pyx_k_readLength), 0, 0, 1, 0},
  {&__pyx_kp_s_read_length, __pyx_k_read_length, sizeof(__pyx_k_read_length), 0, 0, 1, 0},
  {&__pyx_kp_s_readlength, __pyx_k_readlength, sizeof(__pyx_k_readlength), 0, 0, 1, 0},
  {&__pyx_n_s_readlength_2, __pyx_k_readlength_2, sizeof(__pyx_k_readlength_2), 0, 0, 1, 1},
  {&__pyx_n_s_reads, __pyx_k_reads, sizeof(__pyx_k_reads), 0, 0, 1, 1},
  {&__pyx_kp_s_realigner, __pyx_k_realigner, sizeof(__pyx_k_realigner), 0, 0, 1, 0},
  {&__pyx_n_s_realigner_2, __pyx_k_realigner_2, sizeof(__pyx_k_realigner_2), 0, 0, 1, 1},
  {&__pyx_kp_s_ref, __pyx_k_ref, sizeof(__pyx_k_ref), 0, 0, 1, 0},
  {&__pyx_n_s_ref_2, __pyx_k_ref_2, sizeof(__pyx_k_ref_2), 0, 0, 1, 1},
  {&__pyx_kp_s_region_size, __pyx_k_region_size, sizeof(__pyx_k_region_size), 0, 0, 1, 0},
  {&__pyx_n_s_required, __pyx_k_required, sizeof(__pyx_k_required), 0, 0, 1, 1},
  {&__pyx_kp_s_rescue, __pyx_k_rescue, sizeof(__pyx_k_rescue), 0, 0, 1, 0},
  {&__pyx_kp_s_review_dir, __pyx_k_review_dir, sizeof(__pyx_k_review_dir), 0, 0, 1, 0},
  {&__pyx_n_s_rsq, __pyx_k_rsq, sizeof(__pyx_k_rsq), 0, 0, 1, 1},
  {&__pyx_kp_s_s, __pyx_k_s, sizeof(__pyx_k_s), 0, 0, 1, 0},
  {&__pyx_n_s_singleBarcodeTagging, __pyx_k_singleBarcodeTagging, sizeof(__pyx_k_singleBarcodeTagging), 0, 0, 1, 1},
  {&__pyx_kp_s_single_end, __pyx_k_single_end, sizeof(__pyx_k_single_end), 0, 0, 1, 0},
  {&__pyx_n_s_sma, __pyx_k_sma, sizeof(__pyx_k_sma), 0, 0, 1, 1},
  {&__pyx_n_s_snv, __pyx_k_snv, sizeof(__pyx_k_snv), 0, 0, 1, 1},
  {&__pyx_kp_s_sortMem, __pyx_k_sortMem, sizeof(__pyx_k_sortMem), 0, 0, 1, 0},
  {&__pyx_kp_s_std, __pyx_k_std, sizeof(__pyx_k_std), 0, 0, 1, 0},
  {&__pyx_n_s_store_true, __pyx_k_store_true, sizeof(__pyx_k_store_true), 0, 0, 1, 1},
  {&__pyx_n_s_strftime, __pyx_k_strftime, sizeof(__pyx_k_strftime), 0, 0, 1, 1},
  {&__pyx_n_s_subparsers, __pyx_k_subparsers, sizeof(__pyx_k_subparsers), 0, 0, 1, 1},
  {&__pyx_n_s_sv, __pyx_k_sv, sizeof(__pyx_k_sv), 0, 0, 1, 1},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_kp_s_t, __pyx_k_t, sizeof(__pyx_k_t), 0, 0, 1, 0},
  {&__pyx_n_s_tagbam, __pyx_k_tagbam, sizeof(__pyx_k_tagbam), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_kp_s_threads, __pyx_k_threads, sizeof(__pyx_k_threads), 0, 0, 1, 0},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_s_utilBMF_ArgumentSketcher, __pyx_k_utilBMF_ArgumentSketcher, sizeof(__pyx_k_utilBMF_ArgumentSketcher), 0, 0, 1, 1},
  {&__pyx_n_s_utilBMF_GlobalReporting, __pyx_k_utilBMF_GlobalReporting, sizeof(__pyx_k_utilBMF_GlobalReporting), 0, 0, 1, 1},
  {&__pyx_n_s_utilBMF_HTSUtils, __pyx_k_utilBMF_HTSUtils, sizeof(__pyx_k_utilBMF_HTSUtils), 0, 0, 1, 1},
  {&__pyx_n_s_utilBMF_bmftools, __pyx_k_utilBMF_bmftools, sizeof(__pyx_k_utilBMF_bmftools), 0, 0, 1, 1},
  {&__pyx_n_s_v, __pyx_k_v, sizeof(__pyx_k_v), 0, 0, 1, 1},
  {&__pyx_n_s_vcfcmp, __pyx_k_vcfcmp, sizeof(__pyx_k_vcfcmp), 0, 0, 1, 1},
  {&__pyx_n_s_vcfstats, __pyx_k_vcfstats, sizeof(__pyx_k_vcfstats), 0, 0, 1, 1},
  {&__pyx_n_s_versionParser, __pyx_k_versionParser, sizeof(__pyx_k_versionParser), 0, 0, 1, 1},
  {&__pyx_n_s_w, __pyx_k_w, sizeof(__pyx_k_w), 0, 0, 1, 1},
  {&__pyx_kp_s_yggdrasil_workspace_BMFTools_ut, __pyx_k_yggdrasil_workspace_BMFTools_ut, sizeof(__pyx_k_yggdrasil_workspace_BMFTools_ut), 0, 0, 1, 0},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  return 0;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "utilBMF/bmftools":26
 *     parser = argparse.ArgumentParser()
 *     subparsers = parser.add_subparsers(dest="bmfsuites")
 *     MainSubparser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "main", description="Run a full pipeline analysis.")
 *     BedCovParser = subparsers.add_parser(
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_n_s_main); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "utilBMF/bmftools":28
 *     MainSubparser = subparsers.add_parser(
 *         "main", description="Run a full pipeline analysis.")
 *     BedCovParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "bedcov", description="Calls FastDepthOfCoverage.")
 *     alignTagBamParser = subparsers.add_parser(
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_n_s_bedcov); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 28; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "utilBMF/bmftools":30
 *     BedCovParser = subparsers.add_parser(
 *         "bedcov", description="Calls FastDepthOfCoverage.")
 *     alignTagBamParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "aligntagbam", description=("Performs alignment and sam tagging of"
 *                                     " consolidated fastq files to generate "
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_n_s_aligntagbam); if (unlikely(!__pyx_tuple__3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 30; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "utilBMF/bmftools":34
 *                                     " consolidated fastq files to generate "
 *                                     "a tagged bam."))
 *     TagBamParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "tagbam", description=("Tag a BAM file with appropriate information"
 *                                " from merged fastq files."))
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_n_s_tagbam); if (unlikely(!__pyx_tuple__4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "utilBMF/bmftools":37
 *         "tagbam", description=("Tag a BAM file with appropriate information"
 *                                " from merged fastq files."))
 *     RescueShadingParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "rsq", description="Rescue fastq shading.")
 *     versionParser = subparsers.add_parser(
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_n_s_rsq); if (unlikely(!__pyx_tuple__5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 37; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "utilBMF/bmftools":39
 *     RescueShadingParser = subparsers.add_parser(
 *         "rsq", description="Rescue fastq shading.")
 *     versionParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "v", description="Outputs version of BMFTools.")
 *     InputQtyParser = subparsers.add_parser(
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_n_s_v); if (unlikely(!__pyx_tuple__6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 39; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "utilBMF/bmftools":41
 *     versionParser = subparsers.add_parser(
 *         "v", description="Outputs version of BMFTools.")
 *     InputQtyParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "qty",
 *         description=("Calculates the quantity of input DNA needed to reach "
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_n_s_qty); if (unlikely(!__pyx_tuple__7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 41; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "utilBMF/bmftools":46
 *                      "a given mean PCR redundancy and a given amount of "
 *                      "sequencing power."))
 *     PSNVParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "psnv", description="Parallel SNV calls.")
 *     PSNVParser.add_argument(
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_n_s_psnv); if (unlikely(!__pyx_tuple__8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "utilBMF/bmftools":48
 *     PSNVParser = subparsers.add_parser(
 *         "psnv", description="Parallel SNV calls.")
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 48; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "utilBMF/bmftools":52
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--threads",
 *         help="Number of threads.",
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_threads); if (unlikely(!__pyx_tuple__10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "utilBMF/bmftools":56
 *         help="Number of threads.",
 *         type=int)
 *     PSNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outVCF",
 */
  __pyx_tuple__11 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_outVCF); if (unlikely(!__pyx_tuple__11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "utilBMF/bmftools":62
 *         default=None,
 *         metavar="OutputVCF")
 *     PSNVParser.add_argument("inBAM",             # <<<<<<<<<<<<<<
 *                             help="Input BAM, Coordinate-sorted and indexed, "
 *                             "with BMF Tags included. bmftools runs on unflat"
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_n_s_inBAM); if (unlikely(!__pyx_tuple__12)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "utilBMF/bmftools":68
 *                             "cause this program assumes as much.",
 *                             type=str)
 *     VCFCmpParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "vcfcmp", description="Compares VCF files.")
 *     VCFStatsParser = subparsers.add_parser("vcfstats",
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_n_s_vcfcmp); if (unlikely(!__pyx_tuple__13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "utilBMF/bmftools":70
 *     VCFCmpParser = subparsers.add_parser(
 *         "vcfcmp", description="Compares VCF files.")
 *     VCFStatsParser = subparsers.add_parser("vcfstats",             # <<<<<<<<<<<<<<
 *                                            description="Gets counts and"
 *                                            " frequencies for all SNV tr"
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_n_s_vcfstats); if (unlikely(!__pyx_tuple__14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "utilBMF/bmftools":74
 *                                            " frequencies for all SNV tr"
 *                                            "ansitions.")
 *     DMultiPlexParser = subparsers.add_parser("dmp",             # <<<<<<<<<<<<<<
 *                                              description="Marks, combines, and"
 *                                              " processes a dataset of fastqs f"
 */
  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_n_s_dmp); if (unlikely(!__pyx_tuple__15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "utilBMF/bmftools":78
 *                                              " processes a dataset of fastqs f"
 *                                              "or further analysis.")
 *     SNVParser = subparsers.add_parser("snv", description="Call SNVs. Assumes "             # <<<<<<<<<<<<<<
 *                                       "that reads have been collapsed from a "
 *                                       "family size of at least 2")
 */
  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_n_s_snv); if (unlikely(!__pyx_tuple__16)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);

  /* "utilBMF/bmftools":81
 *                                       "that reads have been collapsed from a "
 *                                       "family size of at least 2")
 *     SVParser = subparsers.add_parser("sv",             # <<<<<<<<<<<<<<
 *                                      description="Call structural variants. R"
 *                                      "equires an Input BAM, coordinate-sorted"
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_n_s_sv); if (unlikely(!__pyx_tuple__17)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 81; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "utilBMF/bmftools":86
 *                                      " and indexed, with BMF SV Tags included"
 *                                      ", and a BED File.")
 *     SMAParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "sma",
 *         description="Tool for splitting a VCF File with multiple alts per"
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_n_s_sma); if (unlikely(!__pyx_tuple__18)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "utilBMF/bmftools":90
 *         description="Tool for splitting a VCF File with multiple alts per"
 *         " line into a VCF where each line has a unique alt.")
 *     GetUniqueKmerBedParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "getuniquekmersbed",
 *         description=("Tool for selecting kmers which are unique identifiers "
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_n_s_getuniquekmersbed); if (unlikely(!__pyx_tuple__19)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "utilBMF/bmftools":95
 *                      "for a region of interest for assembly and produces a"
 *                      "bed file covering these regions."))
 *     SNVParser.add_argument("inBAM",             # <<<<<<<<<<<<<<
 *                            help="Input BAM, Coordinate-sorted and indexed, "
 *                            "with BMF Tags included. bmftools runs on unflat"
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_n_s_inBAM); if (unlikely(!__pyx_tuple__20)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "utilBMF/bmftools":100
 *                            "tened BAMs, but the results are not reliable be"
 *                            "cause this program assumes as much.")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed",
 *         "-b",
 */
  __pyx_tuple__21 = PyTuple_Pack(2, __pyx_kp_s_bed, __pyx_kp_s_b); if (unlikely(!__pyx_tuple__21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "utilBMF/bmftools":106
 *         default=None,
 *         metavar="bedpath")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outVCF",
 */
  __pyx_tuple__22 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_outVCF); if (unlikely(!__pyx_tuple__22)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "utilBMF/bmftools":112
 *         default=None,
 *         metavar="OutputVCF")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minBQ",
 *         help="Minimum Base Quality to consider",
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_minBQ); if (unlikely(!__pyx_tuple__23)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "utilBMF/bmftools":117
 *         default=None,
 *         type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minMQ",
 *         help="Minimum Mapping Quality to consider",
 */
  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_minMQ); if (unlikely(!__pyx_tuple__24)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);

  /* "utilBMF/bmftools":122
 *         default=None,
 *         type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--MaxPValue",
 *         "-p",
 */
  __pyx_tuple__25 = PyTuple_Pack(2, __pyx_kp_s_MaxPValue, __pyx_kp_s_p); if (unlikely(!__pyx_tuple__25)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "utilBMF/bmftools":128
 *         type=float,
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--keepConsensus",
 *         "-k",
 */
  __pyx_tuple__26 = PyTuple_Pack(2, __pyx_kp_s_keepConsensus, __pyx_kp_s_k); if (unlikely(!__pyx_tuple__26)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "utilBMF/bmftools":132
 *         "-k",
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--logfile",
 *         help="Name for logfile.",
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_logfile); if (unlikely(!__pyx_tuple__27)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "utilBMF/bmftools":136
 *         help="Name for logfile.",
 *         default=None)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r",
 *         "--ref",
 */
  __pyx_tuple__28 = PyTuple_Pack(2, __pyx_kp_s_r, __pyx_kp_s_ref); if (unlikely(!__pyx_tuple__28)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "utilBMF/bmftools":141
 *         help="Provide reference fasta.",
 *         default=None)
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",             # <<<<<<<<<<<<<<
 *                            default=None, type=int)
 *     SNVParser.add_argument(
 */
  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_minFA); if (unlikely(!__pyx_tuple__29)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__29);
  __Pyx_GIVEREF(__pyx_tuple__29);

  /* "utilBMF/bmftools":143
 *     SNVParser.add_argument("--minFA", help="Minimum family agreed on base.",
 *                            default=None, type=int)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf",
 *         help="Config file to hold this so we don't have to specify.",
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__30)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "utilBMF/bmftools":147
 *         help="Config file to hold this so we don't have to specify.",
 *         type=str)
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--analysisTag", type=str,
 *         help=("Tag to append to the output VCF before the file extension."
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_analysisTag); if (unlikely(!__pyx_tuple__31)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "utilBMF/bmftools":151
 *         help=("Tag to append to the output VCF before the file extension."
 *               "Used to delineate analysis pipelines."))
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--is-slave",
 *         help="Whether or not SNVCrawler is slave instance.",
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_is_slave); if (unlikely(!__pyx_tuple__32)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "utilBMF/bmftools":155
 *         help="Whether or not SNVCrawler is slave instance.",
 *         action="store_true")
 *     SNVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minFracAgreed",
 *         help=("Minimum fraction of reads in family to agree on a base call "
 */
  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_minFracAgreed); if (unlikely(!__pyx_tuple__33)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);

  /* "utilBMF/bmftools":160
 *               "for inclusion in variant calling."),
 *         type=float)
 *     VCFStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inVCF",
 *         help="Input VCF, as created by SNVCrawler.")
 */
  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_n_s_inVCF); if (unlikely(!__pyx_tuple__34)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "utilBMF/bmftools":163
 *         "inVCF",
 *         help="Input VCF, as created by SNVCrawler.")
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFqs",
 *         nargs="+",
 */
  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_n_s_inFqs); if (unlikely(!__pyx_tuple__35)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);

  /* "utilBMF/bmftools":167
 *         nargs="+",
 *         help="Input Fastq Files")
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-i",
 *         "--indexFq",
 */
  __pyx_tuple__37 = PyTuple_Pack(2, __pyx_kp_s_i, __pyx_kp_s_indexFq); if (unlikely(!__pyx_tuple__37)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__37);
  __Pyx_GIVEREF(__pyx_tuple__37);

  /* "utilBMF/bmftools":173
 *         help="Index Fastq",
 *         required=True)
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-f",
 *         "--p5Seq",
 */
  __pyx_tuple__38 = PyTuple_Pack(2, __pyx_kp_s_f, __pyx_kp_s_p5Seq); if (unlikely(!__pyx_tuple__38)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__38);
  __Pyx_GIVEREF(__pyx_tuple__38);

  /* "utilBMF/bmftools":180
 *               "which will run cutadapt to only trim the 3' primer sequence, "
 *               "if given)"))
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-t",
 *         "--p3Seq",
 */
  __pyx_tuple__39 = PyTuple_Pack(2, __pyx_kp_s_t, __pyx_kp_s_p3Seq); if (unlikely(!__pyx_tuple__39)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);

  /* "utilBMF/bmftools":186
 *         help=("3' primer sequence used by cutadapt (defaults to 'default', "
 *               "which will not run cutadapt)"))
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r", "--rescue", action="store_true",
 *         help=("Flag to perform barcode rescue with default rescue parameters "
 */
  __pyx_tuple__40 = PyTuple_Pack(2, __pyx_kp_s_r, __pyx_kp_s_rescue); if (unlikely(!__pyx_tuple__40)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__40);
  __Pyx_GIVEREF(__pyx_tuple__40);

  /* "utilBMF/bmftools":191
 *               "for experiments with very low library diversity. Currently "
 *               "only supported for paired-end reads."))
 *     DMultiPlexParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__41)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__41);
  __Pyx_GIVEREF(__pyx_tuple__41);

  /* "utilBMF/bmftools":196
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFqs",
 *         nargs="+",
 */
  __pyx_tuple__42 = PyTuple_Pack(1, __pyx_n_s_inFqs); if (unlikely(!__pyx_tuple__42)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__42);
  __Pyx_GIVEREF(__pyx_tuple__42);

  /* "utilBMF/bmftools":200
 *         nargs="+",
 *         help="Input Fastq Files")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-b",
 *         "--bed",
 */
  __pyx_tuple__43 = PyTuple_Pack(2, __pyx_kp_s_b, __pyx_kp_s_bed); if (unlikely(!__pyx_tuple__43)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);

  /* "utilBMF/bmftools":206
 *         help=("Bed file not used in the alignment but used in the REalignment"
 *               " and MawCluster.SVUtils's GetSVRelevantRecordsPaired"))
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-r",
 *         "--ref",
 */
  __pyx_tuple__44 = PyTuple_Pack(2, __pyx_kp_s_r, __pyx_kp_s_ref); if (unlikely(!__pyx_tuple__44)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);

  /* "utilBMF/bmftools":211
 *         metavar="ref",
 *         help="Reference FASTA to align fastqs to")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-a",
 *         "--aligner",
 */
  __pyx_tuple__45 = PyTuple_Pack(2, __pyx_kp_s_a, __pyx_kp_s_aligner); if (unlikely(!__pyx_tuple__45)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);

  /* "utilBMF/bmftools":216
 *         metavar="aligner",
 *         help="Aligner program (e.g. bwa mem or bwa aln)")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-g",
 *         "--realigner",
 */
  __pyx_tuple__46 = PyTuple_Pack(2, __pyx_kp_s_g, __pyx_kp_s_realigner); if (unlikely(!__pyx_tuple__46)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__46);
  __Pyx_GIVEREF(__pyx_tuple__46);

  /* "utilBMF/bmftools":221
 *         metavar="realigner",
 *         help="Realigner program (e.g. abra or gatk)")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-p", "--gatkpath",
 *         metavar="gatk",
 */
  __pyx_tuple__47 = PyTuple_Pack(2, __pyx_kp_s_p, __pyx_kp_s_gatkpath); if (unlikely(!__pyx_tuple__47)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);

  /* "utilBMF/bmftools":225
 *         metavar="gatk",
 *         help="Path to the GATK Jar")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-t",
 *         "--abrapath",
 */
  __pyx_tuple__48 = PyTuple_Pack(2, __pyx_kp_s_t, __pyx_kp_s_abrapath); if (unlikely(!__pyx_tuple__48)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__48);
  __Pyx_GIVEREF(__pyx_tuple__48);

  /* "utilBMF/bmftools":230
 *         metavar="abrapath",
 *         help="Path to the abra realigner program")
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-l",
 *         "--readlength",
 */
  __pyx_tuple__49 = PyTuple_Pack(2, __pyx_kp_s_l, __pyx_kp_s_readlength); if (unlikely(!__pyx_tuple__49)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__49);
  __Pyx_GIVEREF(__pyx_tuple__49);

  /* "utilBMF/bmftools":236
 *         help="Read length (for abra.KmerSizeEvaluator program",
 *         type=int)
 *     alignTagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__50)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);

  /* "utilBMF/bmftools":241
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inBAM",
 *         metavar="inBAM",
 */
  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_n_s_inBAM); if (unlikely(!__pyx_tuple__51)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);

  /* "utilBMF/bmftools":245
 *         metavar="inBAM",
 *         help="Untagged Bam, name-sorted")
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--fastq",
 *         "-f",
 */
  __pyx_tuple__52 = PyTuple_Pack(2, __pyx_kp_s_fastq, __pyx_kp_s_f); if (unlikely(!__pyx_tuple__52)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);

  /* "utilBMF/bmftools":251
 *         nargs="+",
 *         help="Tagged, Merged Fastq File(s)")
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile",
 *         help=("Path to output file. If not set, defaults to variation "
 */
  __pyx_tuple__53 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_outfile); if (unlikely(!__pyx_tuple__53)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);

  /* "utilBMF/bmftools":256
 *               "on input bam."),
 *         type=str)
 *     TagBamParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__54 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__54)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__54);
  __Pyx_GIVEREF(__pyx_tuple__54);

  /* "utilBMF/bmftools":261
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         'bam',
 *         help=("Coordinate-Sorted, Indexed Bam File"),
 */
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_n_s_bam); if (unlikely(!__pyx_tuple__55)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);

  /* "utilBMF/bmftools":265
 *         help=("Coordinate-Sorted, Indexed Bam File"),
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-b",
 *         "--bed",
 */
  __pyx_tuple__56 = PyTuple_Pack(2, __pyx_kp_s_b, __pyx_kp_s_bed); if (unlikely(!__pyx_tuple__56)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__56);
  __Pyx_GIVEREF(__pyx_tuple__56);

  /* "utilBMF/bmftools":270
 *         help="Path to bedfile.",
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minMQ",
 *         "-m",
 */
  __pyx_tuple__57 = PyTuple_Pack(2, __pyx_kp_s_minMQ, __pyx_kp_s_m); if (unlikely(!__pyx_tuple__57)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);

  /* "utilBMF/bmftools":275
 *         help="Minimum mapping quality for inclusion. Default: 0.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minBQ",
 *         help="Minimum base quality for inclusion. Default: 0.",
 */
  __pyx_tuple__58 = PyTuple_Pack(1, __pyx_kp_s_minBQ); if (unlikely(!__pyx_tuple__58)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__58);
  __Pyx_GIVEREF(__pyx_tuple__58);

  /* "utilBMF/bmftools":279
 *         help="Minimum base quality for inclusion. Default: 0.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o",
 *         "--outTsv",
 */
  __pyx_tuple__59 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_outTsv); if (unlikely(!__pyx_tuple__59)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "utilBMF/bmftools":284
 *         help="Output tsv",
 *         )
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minPileupLen",
 *         "-l",
 */
  __pyx_tuple__60 = PyTuple_Pack(2, __pyx_kp_s_minPileupLen, __pyx_kp_s_l); if (unlikely(!__pyx_tuple__60)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);

  /* "utilBMF/bmftools":289
 *         help="Length of interval to be considered for call.",
 *         type=int)
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minClustDepth",
 *         "-d",
 */
  __pyx_tuple__61 = PyTuple_Pack(2, __pyx_kp_s_minClustDepth, __pyx_kp_s_d); if (unlikely(!__pyx_tuple__61)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);

  /* "utilBMF/bmftools":294
 *         type=int,
 *         help="Minimum depth for a cluster to be considered for call.")
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref",
 *         "-r",
 */
  __pyx_tuple__62 = PyTuple_Pack(2, __pyx_kp_s_ref, __pyx_kp_s_r); if (unlikely(!__pyx_tuple__62)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);

  /* "utilBMF/bmftools":299
 *         help="Path to reference index.",
 *         required=True)
 *     SVParser.add_argument("--insert-distance",             # <<<<<<<<<<<<<<
 *                           "-i",
 *                           help="Maximum difference between edit distances"
 */
  __pyx_tuple__63 = PyTuple_Pack(2, __pyx_kp_s_insert_distance, __pyx_kp_s_i); if (unlikely(!__pyx_tuple__63)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);

  /* "utilBMF/bmftools":303
 *                           help="Maximum difference between edit distances"
 *                           " for clustering families together")
 *     SVParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__64 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__64)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__64);
  __Pyx_GIVEREF(__pyx_tuple__64);

  /* "utilBMF/bmftools":308
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inVCF",
 *         help="Input VCF", type=str)
 */
  __pyx_tuple__65 = PyTuple_Pack(1, __pyx_n_s_inVCF); if (unlikely(!__pyx_tuple__65)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "utilBMF/bmftools":311
 *         "inVCF",
 *         help="Input VCF", type=str)
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--outVCF",
 *         "-o",
 */
  __pyx_tuple__66 = PyTuple_Pack(2, __pyx_kp_s_outVCF, __pyx_kp_s_o); if (unlikely(!__pyx_tuple__66)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);

  /* "utilBMF/bmftools":315
 *         "-o",
 *         help="Output VCF. If unset, defaults to a modified form of the input.")
 *     SMAParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmfto"
 */
  __pyx_tuple__67 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__67)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);

  /* "utilBMF/bmftools":320
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)
 */
  __pyx_tuple__68 = PyTuple_Pack(1, __pyx_n_s_queryVCF); if (unlikely(!__pyx_tuple__68)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__68);
  __Pyx_GIVEREF(__pyx_tuple__68);

  /* "utilBMF/bmftools":323
 *         "queryVCF", help="Query VCF to compare to reference VCF.",
 *         type=str)
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--std", help="Reference VCF for comparing to query VCF.",
 *         type=str, required=True)
 */
  __pyx_tuple__69 = PyTuple_Pack(1, __pyx_kp_s_std); if (unlikely(!__pyx_tuple__69)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);

  /* "utilBMF/bmftools":326
 *         "--std", help="Reference VCF for comparing to query VCF.",
 *         type=str, required=True)
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile", help="Set output file path instead of stdout.")
 *     VCFCmpParser.add_argument(
 */
  __pyx_tuple__70 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_outfile); if (unlikely(!__pyx_tuple__70)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);

  /* "utilBMF/bmftools":328
 *     VCFCmpParser.add_argument(
 *         "-o", "--outfile", help="Set output file path instead of stdout.")
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--check-std",
 *         help=("If set, check standard VCF for calls in the query VCF rather "
 */
  __pyx_tuple__71 = PyTuple_Pack(1, __pyx_kp_s_check_std); if (unlikely(!__pyx_tuple__71)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__71);
  __Pyx_GIVEREF(__pyx_tuple__71);

  /* "utilBMF/bmftools":334
 *               "calls that should be in the standard."),
 *         action="store_true")
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--check-both", action="store_true",
 *         help=("If set, writes both set comparisons (std vs. query and query "
 */
  __pyx_tuple__72 = PyTuple_Pack(1, __pyx_kp_s_check_both); if (unlikely(!__pyx_tuple__72)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);

  /* "utilBMF/bmftools":339
 *               "vs. standard) for filenames based on the input file name. "
 *               "Stdout not supported."))
 *     VCFCmpParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmfto"
 */
  __pyx_tuple__73 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__73)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__73);
  __Pyx_GIVEREF(__pyx_tuple__73);

  /* "utilBMF/bmftools":344
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--inbed", "-i",
 *         metavar="inbed",
 */
  __pyx_tuple__74 = PyTuple_Pack(2, __pyx_kp_s_inbed, __pyx_kp_s_i); if (unlikely(!__pyx_tuple__74)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__74);
  __Pyx_GIVEREF(__pyx_tuple__74);

  /* "utilBMF/bmftools":350
 *               "interested in searching for unique kmers."),
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref", "-r",
 *         metavar="ref",
 */
  __pyx_tuple__75 = PyTuple_Pack(2, __pyx_kp_s_ref, __pyx_kp_s_r); if (unlikely(!__pyx_tuple__75)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__75);
  __Pyx_GIVEREF(__pyx_tuple__75);

  /* "utilBMF/bmftools":355
 *         help="Path to reference file. (Must be faidx'd)",
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-k", "--kmer", help=("Length of unique sequence groups (kmers) "
 *                               "to search for in the reference."),
 */
  __pyx_tuple__76 = PyTuple_Pack(2, __pyx_kp_s_k, __pyx_kp_s_kmer); if (unlikely(!__pyx_tuple__76)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__76);
  __Pyx_GIVEREF(__pyx_tuple__76);

  /* "utilBMF/bmftools":360
 *         metavar="kmer",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--padding", "-p",
 *         help="Distance around the region of interest to pad.",
 */
  __pyx_tuple__77 = PyTuple_Pack(2, __pyx_kp_s_padding, __pyx_kp_s_p); if (unlikely(!__pyx_tuple__77)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__77);
  __Pyx_GIVEREF(__pyx_tuple__77);

  /* "utilBMF/bmftools":364
 *         help="Distance around the region of interest to pad.",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mismatches", "-m",
 *         metavar="mismatches",
 */
  __pyx_tuple__78 = PyTuple_Pack(2, __pyx_kp_s_mismatches, __pyx_kp_s_m); if (unlikely(!__pyx_tuple__78)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__78);
  __Pyx_GIVEREF(__pyx_tuple__78);

  /* "utilBMF/bmftools":369
 *         help="Number of allowed mismatches.",
 *         type=int)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--outbed", "-o",
 *         metavar="outbed",
 */
  __pyx_tuple__79 = PyTuple_Pack(2, __pyx_kp_s_outbed, __pyx_kp_s_o); if (unlikely(!__pyx_tuple__79)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__79);
  __Pyx_GIVEREF(__pyx_tuple__79);

  /* "utilBMF/bmftools":374
 *         help="Path to output bed file.",
 *         type=str)
 *     GetUniqueKmerBedParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmfto"
 */
  __pyx_tuple__80 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__80)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__80);
  __Pyx_GIVEREF(__pyx_tuple__80);

  /* "utilBMF/bmftools":379
 *                         "ols_helper. Any command-line arguments override thi"
 *                         "s config file as well."))
 *     FamStatsParser = subparsers.add_parser(             # <<<<<<<<<<<<<<
 *         "famstats", description=("Generate family size stats for a "
 *                                  "flattened fastq file."))
 */
  __pyx_tuple__81 = PyTuple_Pack(1, __pyx_n_s_famstats); if (unlikely(!__pyx_tuple__81)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__81);
  __Pyx_GIVEREF(__pyx_tuple__81);

  /* "utilBMF/bmftools":382
 *         "famstats", description=("Generate family size stats for a "
 *                                  "flattened fastq file."))
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inFq", help="Path to flattened fastq file.", type=str)
 *     FamStatsParser.add_argument(
 */
  __pyx_tuple__82 = PyTuple_Pack(1, __pyx_n_s_inFq); if (unlikely(!__pyx_tuple__82)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__82);
  __Pyx_GIVEREF(__pyx_tuple__82);

  /* "utilBMF/bmftools":384
 *     FamStatsParser.add_argument(
 *         "inFq", help="Path to flattened fastq file.", type=str)
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))
 */
  __pyx_tuple__83 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_outfile_handle); if (unlikely(!__pyx_tuple__83)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__83);
  __Pyx_GIVEREF(__pyx_tuple__83);

  /* "utilBMF/bmftools":386
 *     FamStatsParser.add_argument(
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))             # <<<<<<<<<<<<<<
 *     FamStatsParser.add_argument(
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 */
  __pyx_tuple__84 = PyTuple_Pack(1, __pyx_n_s_w); if (unlikely(!__pyx_tuple__84)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__84);
  __Pyx_GIVEREF(__pyx_tuple__84);

  /* "utilBMF/bmftools":387
 *         "-o", "--outfile-handle", help="Path to output file. Default: stdout",
 *         type=argparse.FileType("w"))
 *     FamStatsParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__85 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__85)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__85);
  __Pyx_GIVEREF(__pyx_tuple__85);

  /* "utilBMF/bmftools":392
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-n", "--number-of-templates",
 *         help="Number of template molecules sequenced. "
 */
  __pyx_tuple__86 = PyTuple_Pack(2, __pyx_kp_s_n, __pyx_kp_s_number_of_templates); if (unlikely(!__pyx_tuple__86)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__86);
  __Pyx_GIVEREF(__pyx_tuple__86);

  /* "utilBMF/bmftools":397
 *         "(Both reads in a pair count as 1 total)",
 *         type=int, required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-p", "--paired",
 *         action="store_true",
 */
  __pyx_tuple__87 = PyTuple_Pack(2, __pyx_kp_s_p, __pyx_kp_s_paired); if (unlikely(!__pyx_tuple__87)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__87);
  __Pyx_GIVEREF(__pyx_tuple__87);

  /* "utilBMF/bmftools":401
 *         action="store_true",
 *         help="Set this flag if the data is paired-end.")
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-l", "--read-length",
 *         help="Length of each read.", type=int,
 */
  __pyx_tuple__88 = PyTuple_Pack(2, __pyx_kp_s_l, __pyx_kp_s_read_length); if (unlikely(!__pyx_tuple__88)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__88);
  __Pyx_GIVEREF(__pyx_tuple__88);

  /* "utilBMF/bmftools":405
 *         help="Length of each read.", type=int,
 *         required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--on-target", "-o",
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 */
  __pyx_tuple__89 = PyTuple_Pack(2, __pyx_kp_s_on_target, __pyx_kp_s_o); if (unlikely(!__pyx_tuple__89)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__89);
  __Pyx_GIVEREF(__pyx_tuple__89);

  /* "utilBMF/bmftools":409
 *         help="Fraction of reads which are on-target. Default: 0.25 (25%).",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--region-size", "-s",
 *         help="Size of capture region in number of bases.",
 */
  __pyx_tuple__90 = PyTuple_Pack(2, __pyx_kp_s_region_size, __pyx_kp_s_s); if (unlikely(!__pyx_tuple__90)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__90);
  __Pyx_GIVEREF(__pyx_tuple__90);

  /* "utilBMF/bmftools":413
 *         help="Size of capture region in number of bases.",
 *         type=int, required=True)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--FM", "-f",
 *         help="Desired mean family size.",
 */
  __pyx_tuple__91 = PyTuple_Pack(2, __pyx_kp_s_FM, __pyx_kp_s_f); if (unlikely(!__pyx_tuple__91)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__91);
  __Pyx_GIVEREF(__pyx_tuple__91);

  /* "utilBMF/bmftools":417
 *         help="Desired mean family size.",
 *         required=True, type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--genome-size", "-g",
 *         help="Genome size for organism. Defaults to human genome length.",
 */
  __pyx_tuple__92 = PyTuple_Pack(2, __pyx_kp_s_genome_size, __pyx_kp_s_g); if (unlikely(!__pyx_tuple__92)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__92);
  __Pyx_GIVEREF(__pyx_tuple__92);

  /* "utilBMF/bmftools":421
 *         help="Genome size for organism. Defaults to human genome length.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--no-strand-correction",
 *         help=("Whether or not to count copies of the genome by "
 */
  __pyx_tuple__93 = PyTuple_Pack(1, __pyx_kp_s_no_strand_correction); if (unlikely(!__pyx_tuple__93)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__93);
  __Pyx_GIVEREF(__pyx_tuple__93);

  /* "utilBMF/bmftools":426
 *               "strand rather than by dsDNA."),
 *         action="store_true")
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--qc-fail",
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 */
  __pyx_tuple__94 = PyTuple_Pack(1, __pyx_kp_s_qc_fail); if (unlikely(!__pyx_tuple__94)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__94);
  __Pyx_GIVEREF(__pyx_tuple__94);

  /* "utilBMF/bmftools":430
 *         help="Fraction of reads not usable due to failing QC. Default: 0.1.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mean-aligned-fraction",
 *         help=("Fraction of average read aligned. Default: 0.9"),
 */
  __pyx_tuple__95 = PyTuple_Pack(1, __pyx_kp_s_mean_aligned_fraction); if (unlikely(!__pyx_tuple__95)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__95);
  __Pyx_GIVEREF(__pyx_tuple__95);

  /* "utilBMF/bmftools":434
 *         help=("Fraction of average read aligned. Default: 0.9"),
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mapped-fraction",
 *         help=("Fraction of reads properly mapped with "
 */
  __pyx_tuple__96 = PyTuple_Pack(1, __pyx_kp_s_mapped_fraction); if (unlikely(!__pyx_tuple__96)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__96);
  __Pyx_GIVEREF(__pyx_tuple__96);

  /* "utilBMF/bmftools":439
 *               "MQ != minMQ for variant-calling."),
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ligation-efficiency",
 *         help="Efficiency of ligation of adapters.",
 */
  __pyx_tuple__97 = PyTuple_Pack(1, __pyx_kp_s_ligation_efficiency); if (unlikely(!__pyx_tuple__97)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__97);
  __Pyx_GIVEREF(__pyx_tuple__97);

  /* "utilBMF/bmftools":443
 *         help="Efficiency of ligation of adapters.",
 *         type=float)
 *     InputQtyParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__98 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__98)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__98);
  __Pyx_GIVEREF(__pyx_tuple__98);

  /* "utilBMF/bmftools":448
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)
 */
  __pyx_tuple__99 = PyTuple_Pack(2, __pyx_kp_s_f, __pyx_kp_s_fastqs); if (unlikely(!__pyx_tuple__99)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__99);
  __Pyx_GIVEREF(__pyx_tuple__99);

  /* "utilBMF/bmftools":451
 *         "-f", "--fastqs", help="Path to fastq files.",
 *         nargs="+", type=str)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--head",
 *         help=("Number of bases from each read with "
 */
  __pyx_tuple__100 = PyTuple_Pack(1, __pyx_kp_s_head); if (unlikely(!__pyx_tuple__100)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__100);
  __Pyx_GIVEREF(__pyx_tuple__100);

  /* "utilBMF/bmftools":456
 *               "which to salt the barcode."),
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--mm", help="Mismatch limit",
 *         type=int)
 */
  __pyx_tuple__101 = PyTuple_Pack(1, __pyx_kp_s_mm); if (unlikely(!__pyx_tuple__101)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__101);
  __Pyx_GIVEREF(__pyx_tuple__101);

  /* "utilBMF/bmftools":459
 *         "--mm", help="Mismatch limit",
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minFam", "-m", help="Minimum family size for true families.",
 *         type=int)
 */
  __pyx_tuple__102 = PyTuple_Pack(2, __pyx_kp_s_minFam, __pyx_kp_s_m); if (unlikely(!__pyx_tuple__102)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__102);
  __Pyx_GIVEREF(__pyx_tuple__102);

  /* "utilBMF/bmftools":462
 *         "--minFam", "-m", help="Minimum family size for true families.",
 *         type=int)
 *     RescueShadingParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", help=("Path to a config file. If set, load arguments from "
 *                         "this file, overriding the defaults founds in _bmftoo"
 */
  __pyx_tuple__103 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__103)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__103);
  __Pyx_GIVEREF(__pyx_tuple__103);

  /* "utilBMF/bmftools":467
 *                         "ls_helper. Any command-line arguments override this "
 *                         "config file as well."))
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "inBAM", help="Path to input BAM.")
 *     BedCovParser.add_argument(
 */
  __pyx_tuple__104 = PyTuple_Pack(1, __pyx_n_s_inBAM); if (unlikely(!__pyx_tuple__104)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__104);
  __Pyx_GIVEREF(__pyx_tuple__104);

  /* "utilBMF/bmftools":469
 *     BedCovParser.add_argument(
 *         "inBAM", help="Path to input BAM.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed", "-b", help="Path to bed over which to calculate coverage.")
 *     BedCovParser.add_argument(
 */
  __pyx_tuple__105 = PyTuple_Pack(2, __pyx_kp_s_bed, __pyx_kp_s_b); if (unlikely(!__pyx_tuple__105)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__105);
  __Pyx_GIVEREF(__pyx_tuple__105);

  /* "utilBMF/bmftools":471
 *     BedCovParser.add_argument(
 *         "--bed", "-b", help="Path to bed over which to calculate coverage.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--threads", "-t", help="Number of threads to use.", type=int)
 *     BedCovParser.add_argument(
 */
  __pyx_tuple__106 = PyTuple_Pack(2, __pyx_kp_s_threads, __pyx_kp_s_t); if (unlikely(!__pyx_tuple__106)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__106);
  __Pyx_GIVEREF(__pyx_tuple__106);

  /* "utilBMF/bmftools":473
 *     BedCovParser.add_argument(
 *         "--threads", "-t", help="Number of threads to use.", type=int)
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--FastDOCPath", "-p", help="Path to FastDOC executable jar.")
 *     BedCovParser.add_argument(
 */
  __pyx_tuple__107 = PyTuple_Pack(2, __pyx_kp_s_FastDOCPath, __pyx_kp_s_p); if (unlikely(!__pyx_tuple__107)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__107);
  __Pyx_GIVEREF(__pyx_tuple__107);

  /* "utilBMF/bmftools":475
 *     BedCovParser.add_argument(
 *         "--FastDOCPath", "-p", help="Path to FastDOC executable jar.")
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--conf", "-c", help=("Path to config file. Can be used in place of"
 *                               " any command line arguments."))
 */
  __pyx_tuple__108 = PyTuple_Pack(2, __pyx_kp_s_conf, __pyx_kp_s_c); if (unlikely(!__pyx_tuple__108)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__108);
  __Pyx_GIVEREF(__pyx_tuple__108);

  /* "utilBMF/bmftools":478
 *         "--conf", "-c", help=("Path to config file. Can be used in place of"
 *                               " any command line arguments."))
 *     BedCovParser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bed-buffer",
 *         help=("Number of bases in each direction to pad the bed intervals for"
 */
  __pyx_tuple__109 = PyTuple_Pack(1, __pyx_kp_s_bed_buffer); if (unlikely(!__pyx_tuple__109)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__109);
  __Pyx_GIVEREF(__pyx_tuple__109);

  /* "utilBMF/bmftools":483
 *               " reads bleeding out into surrounding regions."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         'fq',
 *         help="Provide your fastq file(s).",
 */
  __pyx_tuple__110 = PyTuple_Pack(1, __pyx_n_s_fq); if (unlikely(!__pyx_tuple__110)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__110);
  __Pyx_GIVEREF(__pyx_tuple__110);

  /* "utilBMF/bmftools":488
 *         nargs="+",
 *         metavar=('reads'))
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--idxFastq",
 *         "-i",
 */
  __pyx_tuple__111 = PyTuple_Pack(2, __pyx_kp_s_idxFastq, __pyx_kp_s_i); if (unlikely(!__pyx_tuple__111)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__111);
  __Pyx_GIVEREF(__pyx_tuple__111);

  /* "utilBMF/bmftools":493
 *         help="Path to index fastq",
 *         metavar="indexFastq")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--conf',
 *         help="Path to config file with settings.")
 */
  __pyx_tuple__112 = PyTuple_Pack(1, __pyx_kp_s_conf); if (unlikely(!__pyx_tuple__112)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__112);
  __Pyx_GIVEREF(__pyx_tuple__112);

  /* "utilBMF/bmftools":496
 *         '--conf',
 *         help="Path to config file with settings.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-s',
 *         '--single-end',
 */
  __pyx_tuple__113 = PyTuple_Pack(2, __pyx_kp_s_s, __pyx_kp_s_single_end); if (unlikely(!__pyx_tuple__113)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__113);
  __Pyx_GIVEREF(__pyx_tuple__113);

  /* "utilBMF/bmftools":501
 *         help="Whether the experiment is single-end or not. Default: False",
 *         type=bool)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--homing',
 *         help="Homing sequence for samples.",
 */
  __pyx_tuple__114 = PyTuple_Pack(1, __pyx_kp_s_homing); if (unlikely(!__pyx_tuple__114)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__114);
  __Pyx_GIVEREF(__pyx_tuple__114);

  /* "utilBMF/bmftools":505
 *         help="Homing sequence for samples.",
 *         metavar=('HomingSequence'))
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--inline-barcodes',
 *         help="Use flag if using inline barcodes method.",
 */
  __pyx_tuple__115 = PyTuple_Pack(1, __pyx_kp_s_inline_barcodes); if (unlikely(!__pyx_tuple__115)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__115);
  __Pyx_GIVEREF(__pyx_tuple__115);

  /* "utilBMF/bmftools":509
 *         help="Use flag if using inline barcodes method.",
 *         action="store_true")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-a',
 *         '--aligner',
 */
  __pyx_tuple__116 = PyTuple_Pack(2, __pyx_kp_s_a, __pyx_kp_s_aligner); if (unlikely(!__pyx_tuple__116)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__116);
  __Pyx_GIVEREF(__pyx_tuple__116);

  /* "utilBMF/bmftools":515
 *         nargs='?',
 *         metavar='aligner')
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-o',
 *         '--opts',
 */
  __pyx_tuple__118 = PyTuple_Pack(2, __pyx_kp_s_o, __pyx_kp_s_opts); if (unlikely(!__pyx_tuple__118)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__118);
  __Pyx_GIVEREF(__pyx_tuple__118);

  /* "utilBMF/bmftools":519
 *         '--opts',
 *         help="Additional aligner opts. E.g.: --opts '-L 0' ")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-b',
 *         '--BAM',
 */
  __pyx_tuple__119 = PyTuple_Pack(2, __pyx_kp_s_b, __pyx_kp_s_BAM); if (unlikely(!__pyx_tuple__119)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__119);
  __Pyx_GIVEREF(__pyx_tuple__119);

  /* "utilBMF/bmftools":523
 *         '--BAM',
 *         help="BAM file, if alignment has already run.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--bed',
 *         help="full path to bed file used for variant-calling steps."
 */
  __pyx_tuple__120 = PyTuple_Pack(1, __pyx_kp_s_bed); if (unlikely(!__pyx_tuple__120)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__120);
  __Pyx_GIVEREF(__pyx_tuple__120);

  /* "utilBMF/bmftools":528
 *              "Can be indicated by the config file.",
 *         metavar="BEDFile")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-l',
 *         '--logfile',
 */
  __pyx_tuple__121 = PyTuple_Pack(2, __pyx_kp_s_l, __pyx_kp_s_logfile); if (unlikely(!__pyx_tuple__121)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__121);
  __Pyx_GIVEREF(__pyx_tuple__121);

  /* "utilBMF/bmftools":532
 *         '--logfile',
 *         help="To change default logfile location.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '-p',
 *         '--file-prefix',
 */
  __pyx_tuple__122 = PyTuple_Pack(2, __pyx_kp_s_p, __pyx_kp_s_file_prefix); if (unlikely(!__pyx_tuple__122)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__122);
  __Pyx_GIVEREF(__pyx_tuple__122);

  /* "utilBMF/bmftools":536
 *         '--file-prefix',
 *         help="Set non-default prefix.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--minMQ',
 *         help="Minimum mapping quality for variant call inclusion. "
 */
  __pyx_tuple__123 = PyTuple_Pack(1, __pyx_kp_s_minMQ); if (unlikely(!__pyx_tuple__123)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__123);
  __Pyx_GIVEREF(__pyx_tuple__123);

  /* "utilBMF/bmftools":541
 *              "Can be indicated by the config file.",
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         '--minBQ',
 *         help="Minimum base quality for variant call inclusion. "
 */
  __pyx_tuple__124 = PyTuple_Pack(1, __pyx_kp_s_minBQ); if (unlikely(!__pyx_tuple__124)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__124);
  __Pyx_GIVEREF(__pyx_tuple__124);

  /* "utilBMF/bmftools":545
 *         help="Minimum base quality for variant call inclusion. "
 *              "Can be indicated by the config file.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--minCov",
 *         help="Minimum coverage for including a position"
 */
  __pyx_tuple__125 = PyTuple_Pack(1, __pyx_kp_s_minCov); if (unlikely(!__pyx_tuple__125)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__125);
  __Pyx_GIVEREF(__pyx_tuple__125);

  /* "utilBMF/bmftools":549
 *         help="Minimum coverage for including a position"
 *         " in the BamToCoverageBed")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--ref",
 *         "-r",
 */
  __pyx_tuple__126 = PyTuple_Pack(2, __pyx_kp_s_ref, __pyx_kp_s_r); if (unlikely(!__pyx_tuple__126)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__126);
  __Pyx_GIVEREF(__pyx_tuple__126);

  /* "utilBMF/bmftools":553
 *         "-r",
 *         help="Path to reference index. Can be indicated by the config file.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--abrapath",
 *         help="Path to abra jar. Can be indicated by the config file.")
 */
  __pyx_tuple__127 = PyTuple_Pack(1, __pyx_kp_s_abrapath); if (unlikely(!__pyx_tuple__127)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__127);
  __Pyx_GIVEREF(__pyx_tuple__127);

  /* "utilBMF/bmftools":556
 *         "--abrapath",
 *         help="Path to abra jar. Can be indicated by the config file.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--p3Seq", help="3' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(
 */
  __pyx_tuple__128 = PyTuple_Pack(1, __pyx_kp_s_p3Seq); if (unlikely(!__pyx_tuple__128)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__128);
  __Pyx_GIVEREF(__pyx_tuple__128);

  /* "utilBMF/bmftools":558
 *     MainSubparser.add_argument(
 *         "--p3Seq", help="3' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--p5Seq", help="5' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(
 */
  __pyx_tuple__129 = PyTuple_Pack(1, __pyx_kp_s_p5Seq); if (unlikely(!__pyx_tuple__129)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__129);
  __Pyx_GIVEREF(__pyx_tuple__129);

  /* "utilBMF/bmftools":560
 *     MainSubparser.add_argument(
 *         "--p5Seq", help="5' primer sequence for cutadapt.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--review-dir", help="Prefix for review directory, where important re"
 *         "sults files will be moved at the end of analysis.")
 */
  __pyx_tuple__130 = PyTuple_Pack(1, __pyx_kp_s_review_dir); if (unlikely(!__pyx_tuple__130)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__130);
  __Pyx_GIVEREF(__pyx_tuple__130);

  /* "utilBMF/bmftools":563
 *         "--review-dir", help="Prefix for review directory, where important re"
 *         "sults files will be moved at the end of analysis.")
 *     MainSubparser.add_argument("--minFA", help="Minimum family members agreed on bas"             # <<<<<<<<<<<<<<
 *                         "e for inclusion in variant call", type=int)
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"
 */
  __pyx_tuple__131 = PyTuple_Pack(1, __pyx_kp_s_minFA); if (unlikely(!__pyx_tuple__131)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__131);
  __Pyx_GIVEREF(__pyx_tuple__131);

  /* "utilBMF/bmftools":565
 *     MainSubparser.add_argument("--minFA", help="Minimum family members agreed on bas"
 *                         "e for inclusion in variant call", type=int)
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"             # <<<<<<<<<<<<<<
 *                         "r calling PicardTools.")
 *     MainSubparser.add_argument("--indelRealigner", help="Select which indel realigne"
 */
  __pyx_tuple__132 = PyTuple_Pack(1, __pyx_kp_s_picardpath); if (unlikely(!__pyx_tuple__132)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__132);
  __Pyx_GIVEREF(__pyx_tuple__132);

  /* "utilBMF/bmftools":567
 *     MainSubparser.add_argument("--picardpath", help="Path to picard jar. Required fo"
 *                         "r calling PicardTools.")
 *     MainSubparser.add_argument("--indelRealigner", help="Select which indel realigne"             # <<<<<<<<<<<<<<
 *                         "r you wish to use. Supported: abra, GATK. Set to "
 *                         "None to avoid realignment.")
 */
  __pyx_tuple__133 = PyTuple_Pack(1, __pyx_kp_s_indelRealigner); if (unlikely(!__pyx_tuple__133)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__133);
  __Pyx_GIVEREF(__pyx_tuple__133);

  /* "utilBMF/bmftools":570
 *                         "r you wish to use. Supported: abra, GATK. Set to "
 *                         "None to avoid realignment.")
 *     MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")             # <<<<<<<<<<<<<<
 *     MainSubparser.add_argument("--readLength", help="Read length",
 *                         type=int)
 */
  __pyx_tuple__134 = PyTuple_Pack(1, __pyx_kp_s_gatkpath); if (unlikely(!__pyx_tuple__134)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__134);
  __Pyx_GIVEREF(__pyx_tuple__134);

  /* "utilBMF/bmftools":571
 *                         "None to avoid realignment.")
 *     MainSubparser.add_argument("--gatkpath", help="Path to GATK jar. (v1.6)")
 *     MainSubparser.add_argument("--readLength", help="Read length",             # <<<<<<<<<<<<<<
 *                         type=int)
 *     MainSubparser.add_argument("--experiment", "-e",
 */
  __pyx_tuple__135 = PyTuple_Pack(1, __pyx_kp_s_readLength); if (unlikely(!__pyx_tuple__135)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__135);
  __Pyx_GIVEREF(__pyx_tuple__135);

  /* "utilBMF/bmftools":573
 *     MainSubparser.add_argument("--readLength", help="Read length",
 *                         type=int)
 *     MainSubparser.add_argument("--experiment", "-e",             # <<<<<<<<<<<<<<
 *                         help="A comma-joined list of strings with extra infor"
 *                         "mation for informing analysis. Currently in beta sup"
 */
  __pyx_tuple__136 = PyTuple_Pack(2, __pyx_kp_s_experiment, __pyx_kp_s_e); if (unlikely(!__pyx_tuple__136)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__136);
  __Pyx_GIVEREF(__pyx_tuple__136);

  /* "utilBMF/bmftools":577
 *                         "mation for informing analysis. Currently in beta sup"
 *                         "port: ffpe, amplicon.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--intelDeflator",
 *         help="Path to intel deflator. Speeds up abra calls.")
 */
  __pyx_tuple__137 = PyTuple_Pack(1, __pyx_kp_s_intelDeflator); if (unlikely(!__pyx_tuple__137)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__137);
  __Pyx_GIVEREF(__pyx_tuple__137);

  /* "utilBMF/bmftools":580
 *         "--intelDeflator",
 *         help="Path to intel deflator. Speeds up abra calls.")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--sortMem",
 *         help="Memory to use for sorting fastq files. Default: 6G")
 */
  __pyx_tuple__138 = PyTuple_Pack(1, __pyx_kp_s_sortMem); if (unlikely(!__pyx_tuple__138)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 580; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__138);
  __Pyx_GIVEREF(__pyx_tuple__138);

  /* "utilBMF/bmftools":583
 *         "--sortMem",
 *         help="Memory to use for sorting fastq files. Default: 6G")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--bcLen",
 *         help=("Length of inline barcodes. Ignored for datasets where "
 */
  __pyx_tuple__139 = PyTuple_Pack(1, __pyx_kp_s_bcLen); if (unlikely(!__pyx_tuple__139)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__139);
  __Pyx_GIVEREF(__pyx_tuple__139);

  /* "utilBMF/bmftools":588
 *               "the molecular barcode is on a secondary index."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--head", help=("Number of bases from the start of reads 1"
 *                         " and 2 to add to the barcode."),
 */
  __pyx_tuple__140 = PyTuple_Pack(1, __pyx_kp_s_head); if (unlikely(!__pyx_tuple__140)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__140);
  __Pyx_GIVEREF(__pyx_tuple__140);

  /* "utilBMF/bmftools":592
 *                         " and 2 to add to the barcode."),
 *         type=int)
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--parallel",
 *         help="Parallelize variant calling activated by this flag.",
 */
  __pyx_tuple__141 = PyTuple_Pack(1, __pyx_kp_s_parallel); if (unlikely(!__pyx_tuple__141)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__141);
  __Pyx_GIVEREF(__pyx_tuple__141);

  /* "utilBMF/bmftools":596
 *         help="Parallelize variant calling activated by this flag.",
 *         action="store_true")
 *     MainSubparser.add_argument(             # <<<<<<<<<<<<<<
 *         "--rescue", type=str,
 *         help="Set to 'true' to add the rescue step to the family merging.")
 */
  __pyx_tuple__142 = PyTuple_Pack(1, __pyx_kp_s_rescue); if (unlikely(!__pyx_tuple__142)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__142);
  __Pyx_GIVEREF(__pyx_tuple__142);

  /* "utilBMF/bmftools":608
 *     # Global Variables
 *     global Logger
 *     Logger = logging.getLogger("Primarylogger")             # <<<<<<<<<<<<<<
 *     global Chapman
 *     if(hasattr(Palin, "conf") is False):
 */
  __pyx_tuple__143 = PyTuple_Pack(1, __pyx_n_s_Primarylogger); if (unlikely(!__pyx_tuple__143)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__143);
  __Pyx_GIVEREF(__pyx_tuple__143);

  /* "utilBMF/bmftools":621
 *     #
 *     # Declare logging style
 *     dateStr = datetime.datetime.now().strftime("%Y-%b-%d,%H-%m-%S")             # <<<<<<<<<<<<<<
 *     # Begin logging
 *     ## Grabs first non "bmftools
 */
  __pyx_tuple__144 = PyTuple_Pack(1, __pyx_kp_s_Y_b_d_H_m_S); if (unlikely(!__pyx_tuple__144)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__144);
  __Pyx_GIVEREF(__pyx_tuple__144);

  /* "utilBMF/bmftools":624
 *     # Begin logging
 *     ## Grabs first non "bmftools
 *     basename = [i for i in sys.argv[2:] if i[0] != "-"][0]             # <<<<<<<<<<<<<<
 *     print("basename: %s" % basename)
 *     return 0
 */
  __pyx_slice__145 = PySlice_New(__pyx_int_2, Py_None, Py_None); if (unlikely(!__pyx_slice__145)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_slice__145);
  __Pyx_GIVEREF(__pyx_slice__145);

  /* "utilBMF/bmftools":22
 * 
 * 
 * def main():             # <<<<<<<<<<<<<<
 *     import argparse
 *     parser = argparse.ArgumentParser()
 */
  __pyx_tuple__147 = PyTuple_Pack(23, __pyx_n_s_argparse, __pyx_n_s_parser, __pyx_n_s_subparsers, __pyx_n_s_MainSubparser, __pyx_n_s_BedCovParser, __pyx_n_s_alignTagBamParser, __pyx_n_s_TagBamParser, __pyx_n_s_RescueShadingParser, __pyx_n_s_versionParser, __pyx_n_s_InputQtyParser, __pyx_n_s_PSNVParser, __pyx_n_s_VCFCmpParser, __pyx_n_s_VCFStatsParser, __pyx_n_s_DMultiPlexParser, __pyx_n_s_SNVParser, __pyx_n_s_SVParser, __pyx_n_s_SMAParser, __pyx_n_s_GetUniqueKmerBedParser, __pyx_n_s_FamStatsParser, __pyx_n_s_Palin, __pyx_n_s_dateStr, __pyx_n_s_basename, __pyx_n_s_i_2); if (unlikely(!__pyx_tuple__147)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 22; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__147);
  __Pyx_GIVEREF(__pyx_tuple__147);
  __pyx_codeobj__148 = (PyObject*)__Pyx_PyCode_New(0, 0, 23, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__147, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_yggdrasil_workspace_BMFTools_ut, __pyx_n_s_main, 22, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__148)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 22; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initbmftools(void); /*proto*/
PyMODINIT_FUNC initbmftools(void)
#else
PyMODINIT_FUNC PyInit_bmftools(void); /*proto*/
PyMODINIT_FUNC PyInit_bmftools(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_bmftools(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("bmftools", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  if (__pyx_module_is_main_utilBMF__bmftools) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "utilBMF.bmftools")) {
      if (unlikely(PyDict_SetItemString(modules, "utilBMF.bmftools", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "utilBMF/bmftools":2
 * #!/usr/bin/env python
 * import sys             # <<<<<<<<<<<<<<
 * import logging
 * import datetime
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_sys, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":3
 * #!/usr/bin/env python
 * import sys
 * import logging             # <<<<<<<<<<<<<<
 * import datetime
 * from os import path as ospath
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_logging, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_logging, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":4
 * import sys
 * import logging
 * import datetime             # <<<<<<<<<<<<<<
 * from os import path as ospath
 * #  import warnings # Uncomment this if you want to treat warnings as errors.
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_datetime, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_datetime, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":5
 * import logging
 * import datetime
 * from os import path as ospath             # <<<<<<<<<<<<<<
 * #  import warnings # Uncomment this if you want to treat warnings as errors.
 * from utilBMF.HTSUtils import printlog as pl, TrimExt
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_path);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_path);
  __Pyx_GIVEREF(__pyx_n_s_path);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_os, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ospath, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "utilBMF/bmftools":7
 * from os import path as ospath
 * #  import warnings # Uncomment this if you want to treat warnings as errors.
 * from utilBMF.HTSUtils import printlog as pl, TrimExt             # <<<<<<<<<<<<<<
 * from MawCluster.BCBam import pairedBarcodeTagging, singleBarcodeTagging
 * from utilBMF.ArgumentSketcher import ArgumentSketcher
 */
  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_printlog);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_printlog);
  __Pyx_GIVEREF(__pyx_n_s_printlog);
  __Pyx_INCREF(__pyx_n_s_TrimExt);
  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_TrimExt);
  __Pyx_GIVEREF(__pyx_n_s_TrimExt);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_utilBMF_HTSUtils, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_printlog); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pl, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_TrimExt); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TrimExt, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":8
 * #  import warnings # Uncomment this if you want to treat warnings as errors.
 * from utilBMF.HTSUtils import printlog as pl, TrimExt
 * from MawCluster.BCBam import pairedBarcodeTagging, singleBarcodeTagging             # <<<<<<<<<<<<<<
 * from utilBMF.ArgumentSketcher import ArgumentSketcher
 * from utilBMF.GlobalReporting import SampleMetrics, ReviewDirComponents
 */
  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_pairedBarcodeTagging);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_pairedBarcodeTagging);
  __Pyx_GIVEREF(__pyx_n_s_pairedBarcodeTagging);
  __Pyx_INCREF(__pyx_n_s_singleBarcodeTagging);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_singleBarcodeTagging);
  __Pyx_GIVEREF(__pyx_n_s_singleBarcodeTagging);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_MawCluster_BCBam, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_pairedBarcodeTagging); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pairedBarcodeTagging, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_singleBarcodeTagging); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_singleBarcodeTagging, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "utilBMF/bmftools":9
 * from utilBMF.HTSUtils import printlog as pl, TrimExt
 * from MawCluster.BCBam import pairedBarcodeTagging, singleBarcodeTagging
 * from utilBMF.ArgumentSketcher import ArgumentSketcher             # <<<<<<<<<<<<<<
 * from utilBMF.GlobalReporting import SampleMetrics, ReviewDirComponents
 * #  from pudb import set_trace
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_ArgumentSketcher);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_ArgumentSketcher);
  __Pyx_GIVEREF(__pyx_n_s_ArgumentSketcher);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_utilBMF_ArgumentSketcher, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_ArgumentSketcher); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ArgumentSketcher, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "utilBMF/bmftools":10
 * from MawCluster.BCBam import pairedBarcodeTagging, singleBarcodeTagging
 * from utilBMF.ArgumentSketcher import ArgumentSketcher
 * from utilBMF.GlobalReporting import SampleMetrics, ReviewDirComponents             # <<<<<<<<<<<<<<
 * #  from pudb import set_trace
 * 
 */
  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_SampleMetrics);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_SampleMetrics);
  __Pyx_GIVEREF(__pyx_n_s_SampleMetrics);
  __Pyx_INCREF(__pyx_n_s_ReviewDirComponents);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_ReviewDirComponents);
  __Pyx_GIVEREF(__pyx_n_s_ReviewDirComponents);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_utilBMF_GlobalReporting, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_SampleMetrics); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SampleMetrics, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_ReviewDirComponents); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ReviewDirComponents, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 10; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "utilBMF/bmftools":22
 * 
 * 
 * def main():             # <<<<<<<<<<<<<<
 *     import argparse
 *     parser = argparse.ArgumentParser()
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_7utilBMF_8bmftools_1main, NULL, __pyx_n_s_utilBMF_bmftools); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 22; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_main, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 22; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "utilBMF/bmftools":974
 *     return 0
 * 
 * if(__name__ == "__main__"):             # <<<<<<<<<<<<<<
 *     sys.exit(main())
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_name); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_2, __pyx_n_s_main_2, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_3) {

    /* "utilBMF/bmftools":975
 * 
 * if(__name__ == "__main__"):
 *     sys.exit(main())             # <<<<<<<<<<<<<<
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_exit); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_main); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (__pyx_t_6) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else {
      __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
      PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      __pyx_t_1 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "utilBMF/bmftools":1
 * #!/usr/bin/env python             # <<<<<<<<<<<<<<
 * import sys
 * import logging
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init utilBMF.bmftools", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init utilBMF.bmftools");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* --- Runtime support code --- */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject* args = PyTuple_Pack(1, arg);
    return (likely(args)) ? __Pyx_PyObject_Call(func, args, NULL) : NULL;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

static CYTHON_INLINE PyObject* __Pyx_PyObject_GetSlice(
        PyObject* obj, Py_ssize_t cstart, Py_ssize_t cstop,
        PyObject** _py_start, PyObject** _py_stop, PyObject** _py_slice,
        int has_cstart, int has_cstop, CYTHON_UNUSED int wraparound) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyMappingMethods* mp;
#if PY_MAJOR_VERSION < 3
    PySequenceMethods* ms = Py_TYPE(obj)->tp_as_sequence;
    if (likely(ms && ms->sq_slice)) {
        if (!has_cstart) {
            if (_py_start && (*_py_start != Py_None)) {
                cstart = __Pyx_PyIndex_AsSsize_t(*_py_start);
                if ((cstart == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
            } else
                cstart = 0;
        }
        if (!has_cstop) {
            if (_py_stop && (*_py_stop != Py_None)) {
                cstop = __Pyx_PyIndex_AsSsize_t(*_py_stop);
                if ((cstop == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
            } else
                cstop = PY_SSIZE_T_MAX;
        }
        if (wraparound && unlikely((cstart < 0) | (cstop < 0)) && likely(ms->sq_length)) {
            Py_ssize_t l = ms->sq_length(obj);
            if (likely(l >= 0)) {
                if (cstop < 0) {
                    cstop += l;
                    if (cstop < 0) cstop = 0;
                }
                if (cstart < 0) {
                    cstart += l;
                    if (cstart < 0) cstart = 0;
                }
            } else {
                if (PyErr_ExceptionMatches(PyExc_OverflowError))
                    PyErr_Clear();
                else
                    goto bad;
            }
        }
        return ms->sq_slice(obj, cstart, cstop);
    }
#endif
    mp = Py_TYPE(obj)->tp_as_mapping;
    if (likely(mp && mp->mp_subscript))
#endif
    {
        PyObject* result;
        PyObject *py_slice, *py_start, *py_stop;
        if (_py_slice) {
            py_slice = *_py_slice;
        } else {
            PyObject* owned_start = NULL;
            PyObject* owned_stop = NULL;
            if (_py_start) {
                py_start = *_py_start;
            } else {
                if (has_cstart) {
                    owned_start = py_start = PyInt_FromSsize_t(cstart);
                    if (unlikely(!py_start)) goto bad;
                } else
                    py_start = Py_None;
            }
            if (_py_stop) {
                py_stop = *_py_stop;
            } else {
                if (has_cstop) {
                    owned_stop = py_stop = PyInt_FromSsize_t(cstop);
                    if (unlikely(!py_stop)) {
                        Py_XDECREF(owned_start);
                        goto bad;
                    }
                } else
                    py_stop = Py_None;
            }
            py_slice = PySlice_New(py_start, py_stop, Py_None);
            Py_XDECREF(owned_start);
            Py_XDECREF(owned_stop);
            if (unlikely(!py_slice)) goto bad;
        }
#if CYTHON_COMPILING_IN_CPYTHON
        result = mp->mp_subscript(obj, py_slice);
#else
        result = PyObject_GetItem(obj, py_slice);
#endif
        if (!_py_slice) {
            Py_DECREF(py_slice);
        }
        return result;
    }
    PyErr_Format(PyExc_TypeError,
        "'%.200s' object is unsliceable", Py_TYPE(obj)->tp_name);
bad:
    return NULL;
}

static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
                        PyErr_Clear();
                    else
                        return NULL;
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
#if PY_MAJOR_VERSION < 3
    PyObject* owned_ref = NULL;
#endif
    int s1_is_unicode, s2_is_unicode;
    if (s1 == s2) {
        goto return_eq;
    }
    s1_is_unicode = PyUnicode_CheckExact(s1);
    s2_is_unicode = PyUnicode_CheckExact(s2);
#if PY_MAJOR_VERSION < 3
    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
        owned_ref = PyUnicode_FromObject(s2);
        if (unlikely(!owned_ref))
            return -1;
        s2 = owned_ref;
        s2_is_unicode = 1;
    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
        owned_ref = PyUnicode_FromObject(s1);
        if (unlikely(!owned_ref))
            return -1;
        s1 = owned_ref;
        s1_is_unicode = 1;
    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
        return __Pyx_PyBytes_Equals(s1, s2, equals);
    }
#endif
    if (s1_is_unicode & s2_is_unicode) {
        Py_ssize_t length;
        int kind;
        void *data1, *data2;
        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
            return -1;
        length = __Pyx_PyUnicode_GET_LENGTH(s1);
        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
            goto return_ne;
        }
        kind = __Pyx_PyUnicode_KIND(s1);
        if (kind != __Pyx_PyUnicode_KIND(s2)) {
            goto return_ne;
        }
        data1 = __Pyx_PyUnicode_DATA(s1);
        data2 = __Pyx_PyUnicode_DATA(s2);
        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
            goto return_ne;
        } else if (length == 1) {
            goto return_eq;
        } else {
            int result = memcmp(data1, data2, (size_t)(length * kind));
            #if PY_MAJOR_VERSION < 3
            Py_XDECREF(owned_ref);
            #endif
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & s2_is_unicode) {
        goto return_ne;
    } else if ((s2 == Py_None) & s1_is_unicode) {
        goto return_ne;
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
return_eq:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_EQ);
return_ne:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_NE);
#endif
}

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

#if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION < 3
static PyObject *__Pyx_GetStdout(void) {
    PyObject *f = PySys_GetObject((char *)"stdout");
    if (!f) {
        PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
    }
    return f;
}
static int __Pyx_Print(PyObject* f, PyObject *arg_tuple, int newline) {
    int i;
    if (!f) {
        if (!(f = __Pyx_GetStdout()))
            return -1;
    }
    Py_INCREF(f);
    for (i=0; i < PyTuple_GET_SIZE(arg_tuple); i++) {
        PyObject* v;
        if (PyFile_SoftSpace(f, 1)) {
            if (PyFile_WriteString(" ", f) < 0)
                goto error;
        }
        v = PyTuple_GET_ITEM(arg_tuple, i);
        if (PyFile_WriteObject(v, f, Py_PRINT_RAW) < 0)
            goto error;
        if (PyString_Check(v)) {
            char *s = PyString_AsString(v);
            Py_ssize_t len = PyString_Size(v);
            if (len > 0) {
                switch (s[len-1]) {
                    case ' ': break;
                    case '\f': case '\r': case '\n': case '\t': case '\v':
                        PyFile_SoftSpace(f, 0);
                        break;
                    default:  break;
                }
            }
        }
    }
    if (newline) {
        if (PyFile_WriteString("\n", f) < 0)
            goto error;
        PyFile_SoftSpace(f, 0);
    }
    Py_DECREF(f);
    return 0;
error:
    Py_DECREF(f);
    return -1;
}
#else
static int __Pyx_Print(PyObject* stream, PyObject *arg_tuple, int newline) {
    PyObject* kwargs = 0;
    PyObject* result = 0;
    PyObject* end_string;
    if (unlikely(!__pyx_print)) {
        __pyx_print = PyObject_GetAttr(__pyx_b, __pyx_n_s_print);
        if (!__pyx_print)
            return -1;
    }
    if (stream) {
        kwargs = PyDict_New();
        if (unlikely(!kwargs))
            return -1;
        if (unlikely(PyDict_SetItem(kwargs, __pyx_n_s_file, stream) < 0))
            goto bad;
        if (!newline) {
            end_string = PyUnicode_FromStringAndSize(" ", 1);
            if (unlikely(!end_string))
                goto bad;
            if (PyDict_SetItem(kwargs, __pyx_n_s_end, end_string) < 0) {
                Py_DECREF(end_string);
                goto bad;
            }
            Py_DECREF(end_string);
        }
    } else if (!newline) {
        if (unlikely(!__pyx_print_kwargs)) {
            __pyx_print_kwargs = PyDict_New();
            if (unlikely(!__pyx_print_kwargs))
                return -1;
            end_string = PyUnicode_FromStringAndSize(" ", 1);
            if (unlikely(!end_string))
                return -1;
            if (PyDict_SetItem(__pyx_print_kwargs, __pyx_n_s_end, end_string) < 0) {
                Py_DECREF(end_string);
                return -1;
            }
            Py_DECREF(end_string);
        }
        kwargs = __pyx_print_kwargs;
    }
    result = PyObject_Call(__pyx_print, arg_tuple, kwargs);
    if (unlikely(kwargs) && (kwargs != __pyx_print_kwargs))
        Py_DECREF(kwargs);
    if (!result)
        return -1;
    Py_DECREF(result);
    return 0;
bad:
    if (kwargs != __pyx_print_kwargs)
        Py_XDECREF(kwargs);
    return -1;
}
#endif

#if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION < 3
static int __Pyx_PrintOne(PyObject* f, PyObject *o) {
    if (!f) {
        if (!(f = __Pyx_GetStdout()))
            return -1;
    }
    Py_INCREF(f);
    if (PyFile_SoftSpace(f, 0)) {
        if (PyFile_WriteString(" ", f) < 0)
            goto error;
    }
    if (PyFile_WriteObject(o, f, Py_PRINT_RAW) < 0)
        goto error;
    if (PyFile_WriteString("\n", f) < 0)
        goto error;
    Py_DECREF(f);
    return 0;
error:
    Py_DECREF(f);
    return -1;
    /* the line below is just to avoid C compiler
     * warnings about unused functions */
    return __Pyx_Print(f, NULL, 0);
}
#else
static int __Pyx_PrintOne(PyObject* stream, PyObject *o) {
    int res;
    PyObject* arg_tuple = PyTuple_Pack(1, o);
    if (unlikely(!arg_tuple))
        return -1;
    res = __Pyx_Print(stream, arg_tuple, 1);
    Py_DECREF(arg_tuple);
    return res;
}
#endif

#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)       \
    {                                                                     \
        func_type value = func_value;                                     \
        if (sizeof(target_type) < sizeof(func_type)) {                    \
            if (unlikely(value != (func_type) (target_type) value)) {     \
                func_type zero = 0;                                       \
                if (is_unsigned && unlikely(value < zero))                \
                    goto raise_neg_overflow;                              \
                else                                                      \
                    goto raise_overflow;                                  \
            }                                                             \
        }                                                                 \
        return (target_type) value;                                       \
    }

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
 #endif
#endif

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(long) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(long, long, PyLong_AsLong(x))
            } else if (sizeof(long) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(long, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(int, long, PyLong_AsLong(x))
            } else if (sizeof(int) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(int, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if !CYTHON_COMPILING_IN_PYPY
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b)))
      return PyInt_AS_LONG(b);
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
     #if CYTHON_USE_PYLONG_INTERNALS
       switch (Py_SIZE(b)) {
       case -1: return -(sdigit)((PyLongObject*)b)->ob_digit[0];
       case  0: return 0;
       case  1: return ((PyLongObject*)b)->ob_digit[0];
       }
     #endif
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
